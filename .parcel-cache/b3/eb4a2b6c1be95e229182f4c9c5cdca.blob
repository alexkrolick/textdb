// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function(modules, cache, entry, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject.parcelRequire === 'function' &&
    globalObject.parcelRequire;
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x) {
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function(id, exports) {
    modules[id] = [
      function(require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  globalObject.parcelRequire = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function() {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"581c8a36735eb2aed605e6b4b45f0b9f":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = 1234;
var HMR_ENV_HASH = "d751713988987e9331980363e24189ce";
module.bundle.HMR_BUNDLE_ID = "db9d3d9d1423823d5da9daf01e3566b4";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH */

var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var checkedAssets, assetsToAccept, acceptedAssets; // eslint-disable-next-line no-redeclare

var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
  var port = HMR_PORT || location.port;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');

  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    acceptedAssets = {};
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      // Remove error overlay if there is one
      removeErrorOverlay();
      let assets = data.assets.filter(asset => asset.envHash === HMR_ENV_HASH); // Handle HMR Update

      var handled = false;
      assets.forEach(asset => {
        var didAccept = asset.type === 'css' || hmrAcceptCheck(global.parcelRequire, asset.id);

        if (didAccept) {
          handled = true;
        }
      });

      if (handled) {
        console.clear();
        assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });

        for (var i = 0; i < assetsToAccept.length; i++) {
          var id = assetsToAccept[i][1];

          if (!acceptedAssets[id]) {
            hmrAcceptRun(assetsToAccept[i][0], id);
          }
        }
      } else {
        window.location.reload();
      }
    }

    if (data.type === 'error') {
      // Log parcel errors to console
      for (let ansiDiagnostic of data.diagnostics.ansi) {
        let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
        console.error('ðŸš¨ [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
      } // Render the fancy html overlay


      removeErrorOverlay();
      var overlay = createErrorOverlay(data.diagnostics.html);
      document.body.appendChild(overlay);
    }
  };

  ws.onerror = function (e) {
    console.error(e.message);
  };

  ws.onclose = function (e) {
    console.warn('[parcel] ðŸš¨ Connection to the HMR server was lost');
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
    console.log('[parcel] âœ¨ Error resolved');
  }
}

function createErrorOverlay(diagnostics) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID;
  let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';

  for (let diagnostic of diagnostics) {
    let stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
    errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          ðŸš¨ ${diagnostic.message}
        </div>
        <pre>
          ${stack}
        </pre>
        <div>
          ${diagnostic.hints.map(hint => '<div>' + hint + '</div>').join('')}
        </div>
      </div>
    `;
  }

  errorHTML += '</div>';
  overlay.innerHTML = errorHTML;
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push([bundle, k]);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function updateLink(link) {
  var newLink = link.cloneNode();

  newLink.onload = function () {
    if (link.parentNode !== null) {
      link.parentNode.removeChild(link);
    }
  };

  newLink.setAttribute('href', link.getAttribute('href').split('?')[0] + '?' + Date.now());
  link.parentNode.insertBefore(newLink, link.nextSibling);
}

var cssTimeout = null;

function reloadCSS() {
  if (cssTimeout) {
    return;
  }

  cssTimeout = setTimeout(function () {
    var links = document.querySelectorAll('link[rel="stylesheet"]');

    for (var i = 0; i < links.length; i++) {
      var absolute = /^https?:\/\//i.test(links[i].getAttribute('href'));

      if (!absolute) {
        updateLink(links[i]);
      }
    }

    cssTimeout = null;
  }, 50);
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    if (asset.type === 'css') {
      reloadCSS();
    } else {
      var fn = new Function('require', 'module', 'exports', asset.output);
      modules[asset.id] = [fn, asset.depsByBundle[bundle.HMR_BUNDLE_ID]];
    }
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }

  if (checkedAssets[id]) {
    return;
  }

  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (v) {
    return hmrAcceptCheck(v[0], v[1]);
  });
}

function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached && cached.hot) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      var assetsToAlsoAccept = cb(function () {
        return getParents(global.parcelRequire, id);
      });

      if (assetsToAlsoAccept && assetsToAccept.length) {
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
      }
    });
  }

  acceptedAssets[id] = true;
}
},{}],"6b8dee7d259922f234688c1068cceef0":[function(require,module,exports) {
"use strict";

var _preact = require("preact");

var _hooks = require("preact/hooks");

var _xstate = require("xstate");

var io = _interopRequireWildcard(require("./io"));

require("./app.scss");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// import FeatherIcon from "feather-icons-react";
// import { useMachine } from "@xstate/react";
const toggleMachine = (0, _xstate.createMachine)({
  id: "toggle",
  initial: "inactive",
  context: {
    count: 0
  },
  states: {
    inactive: {
      on: {
        TOGGLE: "active"
      }
    },
    active: {
      entry: (0, _xstate.assign)({
        count: ctx => ctx.count + 1
      }),
      on: {
        TOGGLE: "inactive"
      }
    }
  }
});

function reducer(state, action) {}

function App() {
  const [err, setError] = (0, _hooks.useState)(null);
  const [files, setFiles] = (0, _hooks.useState)([]);

  const pickFolder = async () => {
    const folderPath = await io.pickFolder();
    console.log({
      folderPath
    });
    const dirFiles = await io.loadFolder(folderPath).catch(setError);
    console.log({
      dirFiles
    });

    if (dirFiles) {
      setFiles(dirFiles);
    }
  };

  return (0, _preact.h)("div", {
    className: "App"
  }, (0, _preact.h)("div", {
    class: "container py-3 px-3"
  }, (0, _preact.h)("h1", {
    class: "title"
  }, "TextDB"), (0, _preact.h)("p", {
    class: "subtitle"
  }, "Modern Times Are Here At Last"), err && (0, _preact.h)("div", {
    class: "message is-danger"
  }, (0, _preact.h)("div", {
    class: "message-header"
  }, (0, _preact.h)("p", null, "Error"), (0, _preact.h)("button", {
    class: "delete",
    "aria-label": "delete",
    onClick: () => {
      setError(null);
    }
  })), (0, _preact.h)("div", {
    class: "message-body"
  }, err)), (0, _preact.h)("div", {
    class: "field"
  }, (0, _preact.h)("div", {
    class: "control"
  }, (0, _preact.h)("input", {
    class: "input",
    type: "text",
    placeholder: "Input"
  }))), (0, _preact.h)("div", {
    class: "field"
  }, (0, _preact.h)("p", {
    class: "control"
  }, (0, _preact.h)("span", {
    class: "select"
  }, (0, _preact.h)("select", null, files && files.map(f => {
    return (0, _preact.h)("option", {
      value: f.path
    }, f.name);
  }))))), (0, _preact.h)("div", {
    class: "buttons"
  }, (0, _preact.h)("a", {
    class: "button is-primary",
    onClick: pickFolder
  }, "Folder"), (0, _preact.h)("a", {
    class: "button is-link"
  }, "Link"))));
}

(0, _preact.render)((0, _preact.h)(App, null), document.body);
},{"preact":"972ceb4780c8fe42bb292a7cbd55d2e5","preact/hooks":"9fa17bd51cb6bac6d24ad51f7ce5db61","xstate":"21e1c8ceed4fa9a5b8739c840cc5b9cf","./io":"60a98e37deb1add2bb95abeb6c37f73c","./app.scss":"5addf0f372c922390387c0c6184c34bc"}],"972ceb4780c8fe42bb292a7cbd55d2e5":[function(require,module,exports) {
var n,l,u,t,i,r,o={},f=[],e=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function c(n,l){for(var u in l)n[u]=l[u];return n}function s(n){var l=n.parentNode;l&&l.removeChild(n)}function a(n,l,u){var t,i,r,o=arguments,f={};for(r in l)"key"==r?t=l[r]:"ref"==r?i=l[r]:f[r]=l[r];if(arguments.length>3)for(u=[u],r=3;r<arguments.length;r++)u.push(o[r]);if(null!=u&&(f.children=u),"function"==typeof n&&null!=n.defaultProps)for(r in n.defaultProps)void 0===f[r]&&(f[r]=n.defaultProps[r]);return v(n,f,t,i,null)}function v(l,u,t,i,r){var o={type:l,props:u,key:t,ref:i,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:null==r?++n.__v:r};return null!=n.vnode&&n.vnode(o),o}function h(n){return n.children}function p(n,l){this.props=n,this.context=l}function y(n,l){if(null==l)return n.__?y(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return"function"==typeof n.type?y(n):null}function d(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return d(n)}}function _(l){(!l.__d&&(l.__d=!0)&&u.push(l)&&!k.__r++||i!==n.debounceRendering)&&((i=n.debounceRendering)||t)(k)}function k(){for(var n;k.__r=u.length;)n=u.sort(function(n,l){return n.__v.__b-l.__v.__b}),u=[],n.some(function(n){var l,u,t,i,r,o;n.__d&&(r=(i=(l=n).__v).__e,(o=l.__P)&&(u=[],(t=c({},i)).__v=i.__v+1,$(o,i,t,l.__n,void 0!==o.ownerSVGElement,null!=i.__h?[r]:null,u,null==r?y(i):r,i.__h),H(u,i),i.__e!=r&&d(i)))})}function x(n,l,u,t,i,r,e,c,s,a){var p,d,_,k,x,g,w,A=t&&t.__k||f,P=A.length;for(u.__k=[],p=0;p<l.length;p++)if(null!=(k=u.__k[p]=null==(k=l[p])||"boolean"==typeof k?null:"string"==typeof k||"number"==typeof k?v(null,k,null,null,k):Array.isArray(k)?v(h,{children:k},null,null,null):k.__b>0?v(k.type,k.props,k.key,null,k.__v):k)){if(k.__=u,k.__b=u.__b+1,null===(_=A[p])||_&&k.key==_.key&&k.type===_.type)A[p]=void 0;else for(d=0;d<P;d++){if((_=A[d])&&k.key==_.key&&k.type===_.type){A[d]=void 0;break}_=null}$(n,k,_=_||o,i,r,e,c,s,a),x=k.__e,(d=k.ref)&&_.ref!=d&&(w||(w=[]),_.ref&&w.push(_.ref,null,k),w.push(d,k.__c||x,k)),null!=x?(null==g&&(g=x),"function"==typeof k.type&&null!=k.__k&&k.__k===_.__k?k.__d=s=m(k,s,n):s=b(n,k,_,A,x,s),a||"option"!==u.type?"function"==typeof u.type&&(u.__d=s):n.value=""):s&&_.__e==s&&s.parentNode!=n&&(s=y(_))}for(u.__e=g,p=P;p--;)null!=A[p]&&("function"==typeof u.type&&null!=A[p].__e&&A[p].__e==u.__d&&(u.__d=y(t,p+1)),z(A[p],A[p]));if(w)for(p=0;p<w.length;p++)j(w[p],w[++p],w[++p])}function m(n,l,u){var t,i;for(t=0;t<n.__k.length;t++)(i=n.__k[t])&&(i.__=n,l="function"==typeof i.type?m(i,l,u):b(u,i,i,n.__k,i.__e,l));return l}function b(n,l,u,t,i,r){var o,f,e;if(void 0!==l.__d)o=l.__d,l.__d=void 0;else if(null==u||i!=r||null==i.parentNode)n:if(null==r||r.parentNode!==n)n.appendChild(i),o=null;else{for(f=r,e=0;(f=f.nextSibling)&&e<t.length;e+=2)if(f==i)break n;n.insertBefore(i,r),o=r}return void 0!==o?o:i.nextSibling}function g(n,l,u,t,i){var r;for(r in u)"children"===r||"key"===r||r in l||A(n,r,null,u[r],t);for(r in l)i&&"function"!=typeof l[r]||"children"===r||"key"===r||"value"===r||"checked"===r||u[r]===l[r]||A(n,r,l[r],u[r],t)}function w(n,l,u){"-"===l[0]?n.setProperty(l,u):n[l]=null==u?"":"number"!=typeof u||e.test(l)?u:u+"px"}function A(n,l,u,t,i){var r;n:if("style"===l)if("string"==typeof u)n.style.cssText=u;else{if("string"==typeof t&&(n.style.cssText=t=""),t)for(l in t)u&&l in u||w(n.style,l,"");if(u)for(l in u)t&&u[l]===t[l]||w(n.style,l,u[l])}else if("o"===l[0]&&"n"===l[1])r=l!==(l=l.replace(/Capture$/,"")),l=l.toLowerCase()in n?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+r]=u,u?t||n.addEventListener(l,r?C:P,r):n.removeEventListener(l,r?C:P,r);else if("dangerouslySetInnerHTML"!==l){if(i)l=l.replace(/xlink[H:h]/,"h").replace(/sName$/,"s");else if("href"!==l&&"list"!==l&&"form"!==l&&"download"!==l&&l in n)try{n[l]=null==u?"":u;break n}catch(n){}"function"==typeof u||(null!=u&&(!1!==u||"a"===l[0]&&"r"===l[1])?n.setAttribute(l,u):n.removeAttribute(l))}}function P(l){this.l[l.type+!1](n.event?n.event(l):l)}function C(l){this.l[l.type+!0](n.event?n.event(l):l)}function $(l,u,t,i,r,o,f,e,s){var a,v,y,d,_,k,m,b,g,w,A,P=u.type;if(void 0!==u.constructor)return null;null!=t.__h&&(s=t.__h,e=u.__e=t.__e,u.__h=null,o=[e]),(a=n.__b)&&a(u);try{n:if("function"==typeof P){if(b=u.props,g=(a=P.contextType)&&i[a.__c],w=a?g?g.props.value:a.__:i,t.__c?m=(v=u.__c=t.__c).__=v.__E:("prototype"in P&&P.prototype.render?u.__c=v=new P(b,w):(u.__c=v=new p(b,w),v.constructor=P,v.render=I),g&&g.sub(v),v.props=b,v.state||(v.state={}),v.context=w,v.__n=i,y=v.__d=!0,v.__h=[]),null==v.__s&&(v.__s=v.state),null!=P.getDerivedStateFromProps&&(v.__s==v.state&&(v.__s=c({},v.__s)),c(v.__s,P.getDerivedStateFromProps(b,v.__s))),d=v.props,_=v.state,y)null==P.getDerivedStateFromProps&&null!=v.componentWillMount&&v.componentWillMount(),null!=v.componentDidMount&&v.__h.push(v.componentDidMount);else{if(null==P.getDerivedStateFromProps&&b!==d&&null!=v.componentWillReceiveProps&&v.componentWillReceiveProps(b,w),!v.__e&&null!=v.shouldComponentUpdate&&!1===v.shouldComponentUpdate(b,v.__s,w)||u.__v===t.__v){v.props=b,v.state=v.__s,u.__v!==t.__v&&(v.__d=!1),v.__v=u,u.__e=t.__e,u.__k=t.__k,v.__h.length&&f.push(v);break n}null!=v.componentWillUpdate&&v.componentWillUpdate(b,v.__s,w),null!=v.componentDidUpdate&&v.__h.push(function(){v.componentDidUpdate(d,_,k)})}v.context=w,v.props=b,v.state=v.__s,(a=n.__r)&&a(u),v.__d=!1,v.__v=u,v.__P=l,a=v.render(v.props,v.state,v.context),v.state=v.__s,null!=v.getChildContext&&(i=c(c({},i),v.getChildContext())),y||null==v.getSnapshotBeforeUpdate||(k=v.getSnapshotBeforeUpdate(d,_)),A=null!=a&&a.type===h&&null==a.key?a.props.children:a,x(l,Array.isArray(A)?A:[A],u,t,i,r,o,f,e,s),v.base=u.__e,u.__h=null,v.__h.length&&f.push(v),m&&(v.__E=v.__=null),v.__e=!1}else null==o&&u.__v===t.__v?(u.__k=t.__k,u.__e=t.__e):u.__e=T(t.__e,u,t,i,r,o,f,s);(a=n.diffed)&&a(u)}catch(l){u.__v=null,(s||null!=o)&&(u.__e=e,u.__h=!!s,o[o.indexOf(e)]=null),n.__e(l,u,t)}}function H(l,u){n.__c&&n.__c(u,l),l.some(function(u){try{l=u.__h,u.__h=[],l.some(function(n){n.call(u)})}catch(l){n.__e(l,u.__v)}})}function T(n,l,u,t,i,r,e,c){var a,v,h,p,y=u.props,d=l.props,_=l.type,k=0;if("svg"===_&&(i=!0),null!=r)for(;k<r.length;k++)if((a=r[k])&&(a===n||(_?a.localName==_:3==a.nodeType))){n=a,r[k]=null;break}if(null==n){if(null===_)return document.createTextNode(d);n=i?document.createElementNS("http://www.w3.org/2000/svg",_):document.createElement(_,d.is&&d),r=null,c=!1}if(null===_)y===d||c&&n.data===d||(n.data=d);else{if(r=r&&f.slice.call(n.childNodes),v=(y=u.props||o).dangerouslySetInnerHTML,h=d.dangerouslySetInnerHTML,!c){if(null!=r)for(y={},p=0;p<n.attributes.length;p++)y[n.attributes[p].name]=n.attributes[p].value;(h||v)&&(h&&(v&&h.__html==v.__html||h.__html===n.innerHTML)||(n.innerHTML=h&&h.__html||""))}if(g(n,d,y,i,c),h)l.__k=[];else if(k=l.props.children,x(n,Array.isArray(k)?k:[k],l,u,t,i&&"foreignObject"!==_,r,e,n.firstChild,c),null!=r)for(k=r.length;k--;)null!=r[k]&&s(r[k]);c||("value"in d&&void 0!==(k=d.value)&&(k!==n.value||"progress"===_&&!k)&&A(n,"value",k,y.value,!1),"checked"in d&&void 0!==(k=d.checked)&&k!==n.checked&&A(n,"checked",k,y.checked,!1))}return n}function j(l,u,t){try{"function"==typeof l?l(u):l.current=u}catch(l){n.__e(l,t)}}function z(l,u,t){var i,r,o;if(n.unmount&&n.unmount(l),(i=l.ref)&&(i.current&&i.current!==l.__e||j(i,null,u)),t||"function"==typeof l.type||(t=null!=(r=l.__e)),l.__e=l.__d=void 0,null!=(i=l.__c)){if(i.componentWillUnmount)try{i.componentWillUnmount()}catch(l){n.__e(l,u)}i.base=i.__P=null}if(i=l.__k)for(o=0;o<i.length;o++)i[o]&&z(i[o],u,t);null!=r&&s(r)}function I(n,l,u){return this.constructor(n,u)}function L(l,u,t){var i,r,e;n.__&&n.__(l,u),r=(i="function"==typeof t)?null:t&&t.__k||u.__k,e=[],$(u,l=(!i&&t||u).__k=a(h,null,[l]),r||o,o,void 0!==u.ownerSVGElement,!i&&t?[t]:r?null:u.firstChild?f.slice.call(u.childNodes):null,e,!i&&t?t:r?r.__e:u.firstChild,i),H(e,l)}n={__e:function(n,l){for(var u,t,i;l=l.__;)if((u=l.__c)&&!u.__)try{if((t=u.constructor)&&null!=t.getDerivedStateFromError&&(u.setState(t.getDerivedStateFromError(n)),i=u.__d),null!=u.componentDidCatch&&(u.componentDidCatch(n),i=u.__d),i)return u.__E=u}catch(l){n=l}throw n},__v:0},l=function(n){return null!=n&&void 0===n.constructor},p.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=c({},this.state),"function"==typeof n&&(n=n(c({},u),this.props)),n&&c(u,n),null!=n&&this.__v&&(l&&this.__h.push(l),_(this))},p.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),_(this))},p.prototype.render=h,u=[],t="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,k.__r=0,r=0,exports.render=L,exports.hydrate=function n(l,u){L(l,u,n)},exports.createElement=a,exports.h=a,exports.Fragment=h,exports.createRef=function(){return{current:null}},exports.isValidElement=l,exports.Component=p,exports.cloneElement=function(n,l,u){var t,i,r,o=arguments,f=c({},n.props);for(r in l)"key"==r?t=l[r]:"ref"==r?i=l[r]:f[r]=l[r];if(arguments.length>3)for(u=[u],r=3;r<arguments.length;r++)u.push(o[r]);return null!=u&&(f.children=u),v(n.type,f,t||n.key,i||n.ref,null)},exports.createContext=function(n,l){var u={__c:l="__cC"+r++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var u,t;return this.getChildContext||(u=[],(t={})[l]=this,this.getChildContext=function(){return t},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(_)},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Provider.__=u.Consumer.contextType=u},exports.toChildArray=function n(l,u){return u=u||[],null==l||"boolean"==typeof l||(Array.isArray(l)?l.some(function(l){n(l,u)}):u.push(l)),u},exports.options=n;
//# sourceMappingURL=preact.js.map

},{}],"9fa17bd51cb6bac6d24ad51f7ce5db61":[function(require,module,exports) {
var n,t,r,o=require("preact"),u=0,i=[],c=o.options.__b,e=o.options.__r,f=o.options.diffed,a=o.options.__c,v=o.options.unmount;function p(n,r){o.options.__h&&o.options.__h(t,n,u||r),u=0;var i=t.__H||(t.__H={__:[],__h:[]});return n>=i.__.length&&i.__.push({}),i.__[n]}function s(n){return u=1,x(A,n)}function x(r,o,u){var i=p(n++,2);return i.t=r,i.__c||(i.__=[u?u(o):A(void 0,o),function(n){var t=i.t(i.__[0],n);i.__[0]!==t&&(i.__=[t,i.__[1]],i.__c.setState({}))}],i.__c=t),i.__}function m(r,u){var i=p(n++,4);!o.options.__s&&q(i.__H,u)&&(i.__=r,i.__H=u,t.__h.push(i))}function l(t,r){var o=p(n++,7);return q(o.__H,r)&&(o.__=t(),o.__H=r,o.__h=t),o.__}function y(){i.forEach(function(n){if(n.__P)try{n.__H.__h.forEach(_),n.__H.__h.forEach(d),n.__H.__h=[]}catch(t){n.__H.__h=[],o.options.__e(t,n.__v)}}),i=[]}o.options.__b=function(n){t=null,c&&c(n)},o.options.__r=function(r){e&&e(r),n=0;var o=(t=r.__c).__H;o&&(o.__h.forEach(_),o.__h.forEach(d),o.__h=[])},o.options.diffed=function(n){f&&f(n);var u=n.__c;u&&u.__H&&u.__H.__h.length&&(1!==i.push(u)&&r===o.options.requestAnimationFrame||((r=o.options.requestAnimationFrame)||function(n){var t,r=function(){clearTimeout(o),h&&cancelAnimationFrame(t),setTimeout(n)},o=setTimeout(r,100);h&&(t=requestAnimationFrame(r))})(y)),t=void 0},o.options.__c=function(n,t){t.some(function(n){try{n.__h.forEach(_),n.__h=n.__h.filter(function(n){return!n.__||d(n)})}catch(r){t.some(function(n){n.__h&&(n.__h=[])}),t=[],o.options.__e(r,n.__v)}}),a&&a(n,t)},o.options.unmount=function(n){v&&v(n);var t=n.__c;if(t&&t.__H)try{t.__H.__.forEach(_)}catch(n){o.options.__e(n,t.__v)}};var h="function"==typeof requestAnimationFrame;function _(n){var r=t;"function"==typeof n.__c&&n.__c(),t=r}function d(n){var r=t;n.__c=n.__(),t=r}function q(n,t){return!n||n.length!==t.length||t.some(function(t,r){return t!==n[r]})}function A(n,t){return"function"==typeof t?t(n):t}exports.useState=s,exports.useReducer=x,exports.useEffect=function(r,u){var i=p(n++,3);!o.options.__s&&q(i.__H,u)&&(i.__=r,i.__H=u,t.__H.__h.push(i))},exports.useLayoutEffect=m,exports.useRef=function(n){return u=5,l(function(){return{current:n}},[])},exports.useImperativeHandle=function(n,t,r){u=6,m(function(){"function"==typeof n?n(t()):n&&(n.current=t())},null==r?r:r.concat(n))},exports.useMemo=l,exports.useCallback=function(n,t){return u=8,l(function(){return n},t)},exports.useContext=function(r){var o=t.context[r.__c],u=p(n++,9);return u.__c=r,o?(null==u.__&&(u.__=!0,o.sub(t)),o.props.value):r.__},exports.useDebugValue=function(n,t){o.options.useDebugValue&&o.options.useDebugValue(t?t(n):n)},exports.useErrorBoundary=function(r){var o=p(n++,10),u=s();return o.__=r,t.componentDidCatch||(t.componentDidCatch=function(n){o.__&&o.__(n),u[1](n)}),[u[0],function(){u[1](void 0)}]};
//# sourceMappingURL=hooks.js.map

},{"preact":"972ceb4780c8fe42bb292a7cbd55d2e5"}],"21e1c8ceed4fa9a5b8739c840cc5b9cf":[function(require,module,exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMachine = exports.doneInvoke = exports.spawn = exports.matchState = exports.InterpreterStatus = exports.Interpreter = exports.interpret = exports.forwardTo = exports.sendUpdate = exports.sendParent = exports.send = exports.assign = exports.actions = exports.mapState = exports.matchesState = exports.State = exports.StateNode = exports.Machine = void 0;
var utils_1 = require("./utils");
Object.defineProperty(exports, "matchesState", { enumerable: true, get: function () { return utils_1.matchesState; } });
var mapState_1 = require("./mapState");
Object.defineProperty(exports, "mapState", { enumerable: true, get: function () { return mapState_1.mapState; } });
var StateNode_1 = require("./StateNode");
Object.defineProperty(exports, "StateNode", { enumerable: true, get: function () { return StateNode_1.StateNode; } });
var State_1 = require("./State");
Object.defineProperty(exports, "State", { enumerable: true, get: function () { return State_1.State; } });
var Machine_1 = require("./Machine");
Object.defineProperty(exports, "Machine", { enumerable: true, get: function () { return Machine_1.Machine; } });
Object.defineProperty(exports, "createMachine", { enumerable: true, get: function () { return Machine_1.createMachine; } });
var actions_1 = require("./actions");
Object.defineProperty(exports, "send", { enumerable: true, get: function () { return actions_1.send; } });
Object.defineProperty(exports, "sendParent", { enumerable: true, get: function () { return actions_1.sendParent; } });
Object.defineProperty(exports, "sendUpdate", { enumerable: true, get: function () { return actions_1.sendUpdate; } });
Object.defineProperty(exports, "assign", { enumerable: true, get: function () { return actions_1.assign; } });
Object.defineProperty(exports, "doneInvoke", { enumerable: true, get: function () { return actions_1.doneInvoke; } });
Object.defineProperty(exports, "forwardTo", { enumerable: true, get: function () { return actions_1.forwardTo; } });
var interpreter_1 = require("./interpreter");
Object.defineProperty(exports, "interpret", { enumerable: true, get: function () { return interpreter_1.interpret; } });
Object.defineProperty(exports, "Interpreter", { enumerable: true, get: function () { return interpreter_1.Interpreter; } });
Object.defineProperty(exports, "spawn", { enumerable: true, get: function () { return interpreter_1.spawn; } });
Object.defineProperty(exports, "InterpreterStatus", { enumerable: true, get: function () { return interpreter_1.InterpreterStatus; } });
var match_1 = require("./match");
Object.defineProperty(exports, "matchState", { enumerable: true, get: function () { return match_1.matchState; } });
var actions = {
    raise: actions_1.raise,
    send: actions_1.send,
    sendParent: actions_1.sendParent,
    sendUpdate: actions_1.sendUpdate,
    log: actions_1.log,
    cancel: actions_1.cancel,
    start: actions_1.start,
    stop: actions_1.stop,
    assign: actions_1.assign,
    after: actions_1.after,
    done: actions_1.done,
    respond: actions_1.respond,
    forwardTo: actions_1.forwardTo,
    escalate: actions_1.escalate,
    choose: actions_1.choose,
    pure: actions_1.pure
};
exports.actions = actions;
__exportStar(require("./types"), exports);

},{"./utils":"e5f04d71d69884b4184956b7ea1c2036","./mapState":"4374ce40bc3317f79b87b12218ab6761","./StateNode":"d0978d565ef958bc66454c5b956f8408","./State":"fa8df89fc69b67a2024e57052242dafb","./Machine":"dcff83593d02954ff92f02895bb211d7","./actions":"5adc8f58799118d0329ab2c28b9ab1b1","./interpreter":"ce97f2817ba09c038dddca749dbf426c","./match":"89b4c56c2c29d900a21adc9842ee7a36","./types":"c548ffd845c55f4fd347026b8ab58cb7"}],"e5f04d71d69884b4184956b7ea1c2036":[function(require,module,exports) {
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toObserver = exports.toInvokeSource = exports.evaluateGuard = exports.reportUnhandledExceptionOnInvocation = exports.normalizeTarget = exports.toTransitionConfigArray = exports.toSCXMLEvent = exports.toEventObject = exports.uniqueId = exports.isActor = exports.isMachine = exports.symbolObservable = exports.isObservable = exports.toGuard = exports.isString = exports.isFunction = exports.isArray = exports.warn = exports.updateContext = exports.updateHistoryValue = exports.updateHistoryStates = exports.partition = exports.isPromiseLike = exports.isBuiltInEvent = exports.mapContext = exports.toArray = exports.toArrayStrict = exports.flatten = exports.pathsToStateValue = exports.toStatePaths = exports.nestedPath = exports.path = exports.mapFilterValues = exports.mapValues = exports.pathToStateValue = exports.toStateValue = exports.isStateLike = exports.toStatePath = exports.getActionType = exports.getEventType = exports.matchesState = exports.keys = void 0;
var constants_1 = require("./constants");
var environment_1 = require("./environment");
function keys(value) {
    return Object.keys(value);
}
exports.keys = keys;
function matchesState(parentStateId, childStateId, delimiter) {
    if (delimiter === void 0) { delimiter = constants_1.STATE_DELIMITER; }
    var parentStateValue = toStateValue(parentStateId, delimiter);
    var childStateValue = toStateValue(childStateId, delimiter);
    if (isString(childStateValue)) {
        if (isString(parentStateValue)) {
            return childStateValue === parentStateValue;
        }
        // Parent more specific than child
        return false;
    }
    if (isString(parentStateValue)) {
        return parentStateValue in childStateValue;
    }
    return keys(parentStateValue).every(function (key) {
        if (!(key in childStateValue)) {
            return false;
        }
        return matchesState(parentStateValue[key], childStateValue[key]);
    });
}
exports.matchesState = matchesState;
function getEventType(event) {
    try {
        return isString(event) || typeof event === 'number'
            ? "" + event
            : event.type;
    }
    catch (e) {
        throw new Error('Events must be strings or objects with a string event.type property.');
    }
}
exports.getEventType = getEventType;
function getActionType(action) {
    try {
        return isString(action) || typeof action === 'number'
            ? "" + action
            : isFunction(action)
                ? action.name
                : action.type;
    }
    catch (e) {
        throw new Error('Actions must be strings or objects with a string action.type property.');
    }
}
exports.getActionType = getActionType;
function toStatePath(stateId, delimiter) {
    try {
        if (isArray(stateId)) {
            return stateId;
        }
        return stateId.toString().split(delimiter);
    }
    catch (e) {
        throw new Error("'" + stateId + "' is not a valid state path.");
    }
}
exports.toStatePath = toStatePath;
function isStateLike(state) {
    return (typeof state === 'object' &&
        'value' in state &&
        'context' in state &&
        'event' in state &&
        '_event' in state);
}
exports.isStateLike = isStateLike;
function toStateValue(stateValue, delimiter) {
    if (isStateLike(stateValue)) {
        return stateValue.value;
    }
    if (isArray(stateValue)) {
        return pathToStateValue(stateValue);
    }
    if (typeof stateValue !== 'string') {
        return stateValue;
    }
    var statePath = toStatePath(stateValue, delimiter);
    return pathToStateValue(statePath);
}
exports.toStateValue = toStateValue;
function pathToStateValue(statePath) {
    if (statePath.length === 1) {
        return statePath[0];
    }
    var value = {};
    var marker = value;
    for (var i = 0; i < statePath.length - 1; i++) {
        if (i === statePath.length - 2) {
            marker[statePath[i]] = statePath[i + 1];
        }
        else {
            marker[statePath[i]] = {};
            marker = marker[statePath[i]];
        }
    }
    return value;
}
exports.pathToStateValue = pathToStateValue;
function mapValues(collection, iteratee) {
    var result = {};
    var collectionKeys = keys(collection);
    for (var i = 0; i < collectionKeys.length; i++) {
        var key = collectionKeys[i];
        result[key] = iteratee(collection[key], key, collection, i);
    }
    return result;
}
exports.mapValues = mapValues;
function mapFilterValues(collection, iteratee, predicate) {
    var e_1, _a;
    var result = {};
    try {
        for (var _b = __values(keys(collection)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var key = _c.value;
            var item = collection[key];
            if (!predicate(item)) {
                continue;
            }
            result[key] = iteratee(item, key, collection);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return result;
}
exports.mapFilterValues = mapFilterValues;
/**
 * Retrieves a value at the given path.
 * @param props The deep path to the prop of the desired value
 */
var path = function (props) { return function (object) {
    var e_2, _a;
    var result = object;
    try {
        for (var props_1 = __values(props), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {
            var prop = props_1_1.value;
            result = result[prop];
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (props_1_1 && !props_1_1.done && (_a = props_1.return)) _a.call(props_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return result;
}; };
exports.path = path;
/**
 * Retrieves a value at the given path via the nested accessor prop.
 * @param props The deep path to the prop of the desired value
 */
function nestedPath(props, accessorProp) {
    return function (object) {
        var e_3, _a;
        var result = object;
        try {
            for (var props_2 = __values(props), props_2_1 = props_2.next(); !props_2_1.done; props_2_1 = props_2.next()) {
                var prop = props_2_1.value;
                result = result[accessorProp][prop];
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (props_2_1 && !props_2_1.done && (_a = props_2.return)) _a.call(props_2);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return result;
    };
}
exports.nestedPath = nestedPath;
function toStatePaths(stateValue) {
    if (!stateValue) {
        return [[]];
    }
    if (isString(stateValue)) {
        return [[stateValue]];
    }
    var result = flatten(keys(stateValue).map(function (key) {
        var subStateValue = stateValue[key];
        if (typeof subStateValue !== 'string' &&
            (!subStateValue || !Object.keys(subStateValue).length)) {
            return [[key]];
        }
        return toStatePaths(stateValue[key]).map(function (subPath) {
            return [key].concat(subPath);
        });
    }));
    return result;
}
exports.toStatePaths = toStatePaths;
function pathsToStateValue(paths) {
    var e_4, _a;
    var result = {};
    if (paths && paths.length === 1 && paths[0].length === 1) {
        return paths[0][0];
    }
    try {
        for (var paths_1 = __values(paths), paths_1_1 = paths_1.next(); !paths_1_1.done; paths_1_1 = paths_1.next()) {
            var currentPath = paths_1_1.value;
            var marker = result;
            // tslint:disable-next-line:prefer-for-of
            for (var i = 0; i < currentPath.length; i++) {
                var subPath = currentPath[i];
                if (i === currentPath.length - 2) {
                    marker[subPath] = currentPath[i + 1];
                    break;
                }
                marker[subPath] = marker[subPath] || {};
                marker = marker[subPath];
            }
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (paths_1_1 && !paths_1_1.done && (_a = paths_1.return)) _a.call(paths_1);
        }
        finally { if (e_4) throw e_4.error; }
    }
    return result;
}
exports.pathsToStateValue = pathsToStateValue;
function flatten(array) {
    var _a;
    return (_a = []).concat.apply(_a, __spread(array));
}
exports.flatten = flatten;
function toArrayStrict(value) {
    if (isArray(value)) {
        return value;
    }
    return [value];
}
exports.toArrayStrict = toArrayStrict;
function toArray(value) {
    if (value === undefined) {
        return [];
    }
    return toArrayStrict(value);
}
exports.toArray = toArray;
function mapContext(mapper, context, _event) {
    var e_5, _a;
    if (isFunction(mapper)) {
        return mapper(context, _event.data);
    }
    var result = {};
    try {
        for (var _b = __values(Object.keys(mapper)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var key = _c.value;
            var subMapper = mapper[key];
            if (isFunction(subMapper)) {
                result[key] = subMapper(context, _event.data);
            }
            else {
                result[key] = subMapper;
            }
        }
    }
    catch (e_5_1) { e_5 = { error: e_5_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_5) throw e_5.error; }
    }
    return result;
}
exports.mapContext = mapContext;
function isBuiltInEvent(eventType) {
    return /^(done|error)\./.test(eventType);
}
exports.isBuiltInEvent = isBuiltInEvent;
function isPromiseLike(value) {
    if (value instanceof Promise) {
        return true;
    }
    // Check if shape matches the Promise/A+ specification for a "thenable".
    if (value !== null &&
        (isFunction(value) || typeof value === 'object') &&
        isFunction(value.then)) {
        return true;
    }
    return false;
}
exports.isPromiseLike = isPromiseLike;
function partition(items, predicate) {
    var e_6, _a;
    var _b = __read([[], []], 2), truthy = _b[0], falsy = _b[1];
    try {
        for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
            var item = items_1_1.value;
            if (predicate(item)) {
                truthy.push(item);
            }
            else {
                falsy.push(item);
            }
        }
    }
    catch (e_6_1) { e_6 = { error: e_6_1 }; }
    finally {
        try {
            if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
        }
        finally { if (e_6) throw e_6.error; }
    }
    return [truthy, falsy];
}
exports.partition = partition;
function updateHistoryStates(hist, stateValue) {
    return mapValues(hist.states, function (subHist, key) {
        if (!subHist) {
            return undefined;
        }
        var subStateValue = (isString(stateValue) ? undefined : stateValue[key]) ||
            (subHist ? subHist.current : undefined);
        if (!subStateValue) {
            return undefined;
        }
        return {
            current: subStateValue,
            states: updateHistoryStates(subHist, subStateValue)
        };
    });
}
exports.updateHistoryStates = updateHistoryStates;
function updateHistoryValue(hist, stateValue) {
    return {
        current: stateValue,
        states: updateHistoryStates(hist, stateValue)
    };
}
exports.updateHistoryValue = updateHistoryValue;
function updateContext(context, _event, assignActions, state) {
    if (!environment_1.IS_PRODUCTION) {
        warn(!!context, 'Attempting to update undefined context');
    }
    var updatedContext = context
        ? assignActions.reduce(function (acc, assignAction) {
            var e_7, _a;
            var assignment = assignAction.assignment;
            var meta = {
                state: state,
                action: assignAction,
                _event: _event
            };
            var partialUpdate = {};
            if (isFunction(assignment)) {
                partialUpdate = assignment(acc, _event.data, meta);
            }
            else {
                try {
                    for (var _b = __values(keys(assignment)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var key = _c.value;
                        var propAssignment = assignment[key];
                        partialUpdate[key] = isFunction(propAssignment)
                            ? propAssignment(acc, _event.data, meta)
                            : propAssignment;
                    }
                }
                catch (e_7_1) { e_7 = { error: e_7_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_7) throw e_7.error; }
                }
            }
            return Object.assign({}, acc, partialUpdate);
        }, context)
        : context;
    return updatedContext;
}
exports.updateContext = updateContext;
// tslint:disable-next-line:no-empty
var warn = function () { };
exports.warn = warn;
if (!environment_1.IS_PRODUCTION) {
    exports.warn = warn = function (condition, message) {
        var error = condition instanceof Error ? condition : undefined;
        if (!error && condition) {
            return;
        }
        if (console !== undefined) {
            var args = ["Warning: " + message];
            if (error) {
                args.push(error);
            }
            // tslint:disable-next-line:no-console
            console.warn.apply(console, args);
        }
    };
}
function isArray(value) {
    return Array.isArray(value);
}
exports.isArray = isArray;
// tslint:disable-next-line:ban-types
function isFunction(value) {
    return typeof value === 'function';
}
exports.isFunction = isFunction;
function isString(value) {
    return typeof value === 'string';
}
exports.isString = isString;
// export function memoizedGetter<T, TP extends { prototype: object }>(
//   o: TP,
//   property: string,
//   getter: () => T
// ): void {
//   Object.defineProperty(o.prototype, property, {
//     get: getter,
//     enumerable: false,
//     configurable: false
//   });
// }
function toGuard(condition, guardMap) {
    if (!condition) {
        return undefined;
    }
    if (isString(condition)) {
        return {
            type: constants_1.DEFAULT_GUARD_TYPE,
            name: condition,
            predicate: guardMap ? guardMap[condition] : undefined
        };
    }
    if (isFunction(condition)) {
        return {
            type: constants_1.DEFAULT_GUARD_TYPE,
            name: condition.name,
            predicate: condition
        };
    }
    return condition;
}
exports.toGuard = toGuard;
function isObservable(value) {
    try {
        return 'subscribe' in value && isFunction(value.subscribe);
    }
    catch (e) {
        return false;
    }
}
exports.isObservable = isObservable;
exports.symbolObservable = (function () {
    return (typeof Symbol === 'function' && Symbol.observable) ||
        '@@observable';
})();
function isMachine(value) {
    try {
        return '__xstatenode' in value;
    }
    catch (e) {
        return false;
    }
}
exports.isMachine = isMachine;
function isActor(value) {
    return !!value && typeof value.send === 'function';
}
exports.isActor = isActor;
exports.uniqueId = (function () {
    var currentId = 0;
    return function () {
        currentId++;
        return currentId.toString(16);
    };
})();
function toEventObject(event, payload
// id?: TEvent['type']
) {
    if (isString(event) || typeof event === 'number') {
        return __assign({ type: event }, payload);
    }
    return event;
}
exports.toEventObject = toEventObject;
function toSCXMLEvent(event, scxmlEvent) {
    if (!isString(event) && '$$type' in event && event.$$type === 'scxml') {
        return event;
    }
    var eventObject = toEventObject(event);
    return __assign({ name: eventObject.type, data: eventObject, $$type: 'scxml', type: 'external' }, scxmlEvent);
}
exports.toSCXMLEvent = toSCXMLEvent;
function toTransitionConfigArray(event, configLike) {
    var transitions = toArrayStrict(configLike).map(function (transitionLike) {
        if (typeof transitionLike === 'undefined' ||
            typeof transitionLike === 'string' ||
            isMachine(transitionLike)) {
            return { target: transitionLike, event: event };
        }
        return __assign(__assign({}, transitionLike), { event: event });
    });
    return transitions;
}
exports.toTransitionConfigArray = toTransitionConfigArray;
function normalizeTarget(target) {
    if (target === undefined || target === constants_1.TARGETLESS_KEY) {
        return undefined;
    }
    return toArray(target);
}
exports.normalizeTarget = normalizeTarget;
function reportUnhandledExceptionOnInvocation(originalError, currentError, id) {
    if (!environment_1.IS_PRODUCTION) {
        var originalStackTrace = originalError.stack
            ? " Stacktrace was '" + originalError.stack + "'"
            : '';
        if (originalError === currentError) {
            // tslint:disable-next-line:no-console
            console.error("Missing onError handler for invocation '" + id + "', error was '" + originalError + "'." + originalStackTrace);
        }
        else {
            var stackTrace = currentError.stack
                ? " Stacktrace was '" + currentError.stack + "'"
                : '';
            // tslint:disable-next-line:no-console
            console.error("Missing onError handler and/or unhandled exception/promise rejection for invocation '" + id + "'. " +
                ("Original error: '" + originalError + "'. " + originalStackTrace + " Current error is '" + currentError + "'." + stackTrace));
        }
    }
}
exports.reportUnhandledExceptionOnInvocation = reportUnhandledExceptionOnInvocation;
function evaluateGuard(machine, guard, context, _event, state) {
    var guards = machine.options.guards;
    var guardMeta = {
        state: state,
        cond: guard,
        _event: _event
    };
    // TODO: do not hardcode!
    if (guard.type === constants_1.DEFAULT_GUARD_TYPE) {
        return guard.predicate(context, _event.data, guardMeta);
    }
    var condFn = guards[guard.type];
    if (!condFn) {
        throw new Error("Guard '" + guard.type + "' is not implemented on machine '" + machine.id + "'.");
    }
    return condFn(context, _event.data, guardMeta);
}
exports.evaluateGuard = evaluateGuard;
function toInvokeSource(src) {
    if (typeof src === 'string') {
        return { type: src };
    }
    return src;
}
exports.toInvokeSource = toInvokeSource;
function toObserver(nextHandler, errorHandler, completionHandler) {
    if (typeof nextHandler === 'object') {
        return nextHandler;
    }
    var noop = function () { return void 0; };
    return {
        next: nextHandler,
        error: errorHandler || noop,
        complete: completionHandler || noop
    };
}
exports.toObserver = toObserver;

},{"./constants":"60ce741ac53d1e94aa8807a548293ad5","./environment":"6dbe9637d67ccc4648d820c8714c7766"}],"60ce741ac53d1e94aa8807a548293ad5":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TARGETLESS_KEY = exports.DEFAULT_GUARD_TYPE = exports.EMPTY_ACTIVITY_MAP = exports.STATE_DELIMITER = void 0;
exports.STATE_DELIMITER = '.';
exports.EMPTY_ACTIVITY_MAP = {};
exports.DEFAULT_GUARD_TYPE = 'xstate.guard';
exports.TARGETLESS_KEY = '';

},{}],"6dbe9637d67ccc4648d820c8714c7766":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IS_PRODUCTION = void 0;
exports.IS_PRODUCTION = "development" === 'production';
},{}],"4374ce40bc3317f79b87b12218ab6761":[function(require,module,exports) {
"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapState = void 0;
var utils_1 = require("./utils");
function mapState(stateMap, stateId) {
    var e_1, _a;
    var foundStateId;
    try {
        for (var _b = __values(utils_1.keys(stateMap)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var mappedStateId = _c.value;
            if (utils_1.matchesState(mappedStateId, stateId) &&
                (!foundStateId || stateId.length > foundStateId.length)) {
                foundStateId = mappedStateId;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return stateMap[foundStateId];
}
exports.mapState = mapState;

},{"./utils":"e5f04d71d69884b4184956b7ea1c2036"}],"d0978d565ef958bc66454c5b956f8408":[function(require,module,exports) {
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StateNode = void 0;
var utils_1 = require("./utils");
var types_1 = require("./types");
var utils_2 = require("./utils");
var State_1 = require("./State");
var actionTypes = require("./actionTypes");
var actions_1 = require("./actions");
var environment_1 = require("./environment");
var constants_1 = require("./constants");
var stateUtils_1 = require("./stateUtils");
var Actor_1 = require("./Actor");
var invokeUtils_1 = require("./invokeUtils");
var NULL_EVENT = '';
var STATE_IDENTIFIER = '#';
var WILDCARD = '*';
var EMPTY_OBJECT = {};
var isStateId = function (str) { return str[0] === STATE_IDENTIFIER; };
var createDefaultOptions = function () { return ({
    actions: {},
    guards: {},
    services: {},
    activities: {},
    delays: {}
}); };
var validateArrayifiedTransitions = function (stateNode, event, transitions) {
    var hasNonLastUnguardedTarget = transitions
        .slice(0, -1)
        .some(function (transition) {
        return !('cond' in transition) &&
            !('in' in transition) &&
            (utils_1.isString(transition.target) || utils_1.isMachine(transition.target));
    });
    var eventText = event === NULL_EVENT ? 'the transient event' : "event '" + event + "'";
    utils_1.warn(!hasNonLastUnguardedTarget, "One or more transitions for " + eventText + " on state '" + stateNode.id + "' are unreachable. " +
        "Make sure that the default transition is the last one defined.");
};
var StateNode = /** @class */ (function () {
    function StateNode(
    /**
     * The raw config used to create the machine.
     */
    config, options, 
    /**
     * The initial extended state
     */
    context) {
        var _this = this;
        this.config = config;
        this.context = context;
        /**
         * The order this state node appears. Corresponds to the implicit SCXML document order.
         */
        this.order = -1;
        this.__xstatenode = true;
        this.__cache = {
            events: undefined,
            relativeValue: new Map(),
            initialStateValue: undefined,
            initialState: undefined,
            on: undefined,
            transitions: undefined,
            candidates: {},
            delayedTransitions: undefined
        };
        this.idMap = {};
        this.options = Object.assign(createDefaultOptions(), options);
        this.parent = this.options._parent;
        this.key =
            this.config.key || this.options._key || this.config.id || '(machine)';
        this.machine = this.parent ? this.parent.machine : this;
        this.path = this.parent ? this.parent.path.concat(this.key) : [];
        this.delimiter =
            this.config.delimiter ||
                (this.parent ? this.parent.delimiter : constants_1.STATE_DELIMITER);
        this.id =
            this.config.id || __spread([this.machine.key], this.path).join(this.delimiter);
        this.version = this.parent
            ? this.parent.version
            : this.config.version;
        this.type =
            this.config.type ||
                (this.config.parallel
                    ? 'parallel'
                    : this.config.states && utils_1.keys(this.config.states).length
                        ? 'compound'
                        : this.config.history
                            ? 'history'
                            : 'atomic');
        if (!environment_1.IS_PRODUCTION) {
            utils_1.warn(!('parallel' in this.config), "The \"parallel\" property is deprecated and will be removed in version 4.1. " + (this.config.parallel
                ? "Replace with `type: 'parallel'`"
                : "Use `type: '" + this.type + "'`") + " in the config for state node '" + this.id + "' instead.");
        }
        this.initial = this.config.initial;
        this.states = (this.config.states
            ? utils_1.mapValues(this.config.states, function (stateConfig, key) {
                var _a;
                var stateNode = new StateNode(stateConfig, {
                    _parent: _this,
                    _key: key
                });
                Object.assign(_this.idMap, __assign((_a = {}, _a[stateNode.id] = stateNode, _a), stateNode.idMap));
                return stateNode;
            })
            : EMPTY_OBJECT);
        // Document order
        var order = 0;
        function dfs(stateNode) {
            var e_1, _a;
            stateNode.order = order++;
            try {
                for (var _b = __values(stateUtils_1.getChildren(stateNode)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var child = _c.value;
                    dfs(child);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        dfs(this);
        // History config
        this.history =
            this.config.history === true ? 'shallow' : this.config.history || false;
        this._transient =
            !!this.config.always ||
                (!this.config.on
                    ? false
                    : Array.isArray(this.config.on)
                        ? this.config.on.some(function (_a) {
                            var event = _a.event;
                            return event === NULL_EVENT;
                        })
                        : NULL_EVENT in this.config.on);
        this.strict = !!this.config.strict;
        // TODO: deprecate (entry)
        this.onEntry = utils_1.toArray(this.config.entry || this.config.onEntry).map(function (action) { return actions_1.toActionObject(action); });
        // TODO: deprecate (exit)
        this.onExit = utils_1.toArray(this.config.exit || this.config.onExit).map(function (action) { return actions_1.toActionObject(action); });
        this.meta = this.config.meta;
        this.doneData =
            this.type === 'final'
                ? this.config.data
                : undefined;
        this.invoke = utils_1.toArray(this.config.invoke).map(function (invokeConfig, i) {
            var _a, _b;
            if (utils_1.isMachine(invokeConfig)) {
                _this.machine.options.services = __assign((_a = {}, _a[invokeConfig.id] = invokeConfig, _a), _this.machine.options.services);
                return invokeUtils_1.toInvokeDefinition({
                    src: invokeConfig.id,
                    id: invokeConfig.id
                });
            }
            else if (utils_1.isString(invokeConfig.src)) {
                return invokeUtils_1.toInvokeDefinition(__assign(__assign({}, invokeConfig), { id: invokeConfig.id || invokeConfig.src, src: invokeConfig.src }));
            }
            else if (utils_1.isMachine(invokeConfig.src) || utils_1.isFunction(invokeConfig.src)) {
                var invokeSrc = _this.id + ":invocation[" + i + "]"; // TODO: util function
                _this.machine.options.services = __assign((_b = {}, _b[invokeSrc] = invokeConfig.src, _b), _this.machine.options.services);
                return invokeUtils_1.toInvokeDefinition(__assign(__assign({ id: invokeSrc }, invokeConfig), { src: invokeSrc }));
            }
            else {
                var invokeSource = invokeConfig.src;
                return invokeUtils_1.toInvokeDefinition(__assign(__assign({ id: invokeSource.type }, invokeConfig), { src: invokeSource }));
            }
        });
        this.activities = utils_1.toArray(this.config.activities)
            .concat(this.invoke)
            .map(function (activity) { return actions_1.toActivityDefinition(activity); });
        this.transition = this.transition.bind(this);
        // TODO: this is the real fix for initialization once
        // state node getters are deprecated
        // if (!this.parent) {
        //   this._init();
        // }
    }
    StateNode.prototype._init = function () {
        if (this.__cache.transitions) {
            return;
        }
        stateUtils_1.getAllStateNodes(this).forEach(function (stateNode) { return stateNode.on; });
    };
    /**
     * Clones this state machine with custom options and context.
     *
     * @param options Options (actions, guards, activities, services) to recursively merge with the existing options.
     * @param context Custom context (will override predefined context)
     */
    StateNode.prototype.withConfig = function (options, context) {
        if (context === void 0) { context = this.context; }
        var _a = this.options, actions = _a.actions, activities = _a.activities, guards = _a.guards, services = _a.services, delays = _a.delays;
        return new StateNode(this.config, {
            actions: __assign(__assign({}, actions), options.actions),
            activities: __assign(__assign({}, activities), options.activities),
            guards: __assign(__assign({}, guards), options.guards),
            services: __assign(__assign({}, services), options.services),
            delays: __assign(__assign({}, delays), options.delays)
        }, context);
    };
    /**
     * Clones this state machine with custom context.
     *
     * @param context Custom context (will override predefined context, not recursive)
     */
    StateNode.prototype.withContext = function (context) {
        return new StateNode(this.config, this.options, context);
    };
    Object.defineProperty(StateNode.prototype, "definition", {
        /**
         * The well-structured state node definition.
         */
        get: function () {
            return {
                id: this.id,
                key: this.key,
                version: this.version,
                context: this.context,
                type: this.type,
                initial: this.initial,
                history: this.history,
                states: utils_1.mapValues(this.states, function (state) { return state.definition; }),
                on: this.on,
                transitions: this.transitions,
                entry: this.onEntry,
                exit: this.onExit,
                activities: this.activities || [],
                meta: this.meta,
                order: this.order || -1,
                data: this.doneData,
                invoke: this.invoke
            };
        },
        enumerable: false,
        configurable: true
    });
    StateNode.prototype.toJSON = function () {
        return this.definition;
    };
    Object.defineProperty(StateNode.prototype, "on", {
        /**
         * The mapping of events to transitions.
         */
        get: function () {
            if (this.__cache.on) {
                return this.__cache.on;
            }
            var transitions = this.transitions;
            return (this.__cache.on = transitions.reduce(function (map, transition) {
                map[transition.eventType] = map[transition.eventType] || [];
                map[transition.eventType].push(transition);
                return map;
            }, {}));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StateNode.prototype, "after", {
        get: function () {
            return (this.__cache.delayedTransitions ||
                ((this.__cache.delayedTransitions = this.getDelayedTransitions()),
                    this.__cache.delayedTransitions));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StateNode.prototype, "transitions", {
        /**
         * All the transitions that can be taken from this state node.
         */
        get: function () {
            return (this.__cache.transitions ||
                ((this.__cache.transitions = this.formatTransitions()),
                    this.__cache.transitions));
        },
        enumerable: false,
        configurable: true
    });
    StateNode.prototype.getCandidates = function (eventName) {
        if (this.__cache.candidates[eventName]) {
            return this.__cache.candidates[eventName];
        }
        var transient = eventName === NULL_EVENT;
        var candidates = this.transitions.filter(function (transition) {
            var sameEventType = transition.eventType === eventName;
            // null events should only match against eventless transitions
            return transient
                ? sameEventType
                : sameEventType || transition.eventType === WILDCARD;
        });
        this.__cache.candidates[eventName] = candidates;
        return candidates;
    };
    /**
     * All delayed transitions from the config.
     */
    StateNode.prototype.getDelayedTransitions = function () {
        var _this = this;
        var afterConfig = this.config.after;
        if (!afterConfig) {
            return [];
        }
        var mutateEntryExit = function (delay, i) {
            var delayRef = utils_1.isFunction(delay) ? _this.id + ":delay[" + i + "]" : delay;
            var eventType = actions_1.after(delayRef, _this.id);
            _this.onEntry.push(actions_1.send(eventType, { delay: delay }));
            _this.onExit.push(actions_1.cancel(eventType));
            return eventType;
        };
        var delayedTransitions = utils_1.isArray(afterConfig)
            ? afterConfig.map(function (transition, i) {
                var eventType = mutateEntryExit(transition.delay, i);
                return __assign(__assign({}, transition), { event: eventType });
            })
            : utils_1.flatten(utils_1.keys(afterConfig).map(function (delay, i) {
                var configTransition = afterConfig[delay];
                var resolvedTransition = utils_1.isString(configTransition)
                    ? { target: configTransition }
                    : configTransition;
                var resolvedDelay = !isNaN(+delay) ? +delay : delay;
                var eventType = mutateEntryExit(resolvedDelay, i);
                return utils_1.toArray(resolvedTransition).map(function (transition) { return (__assign(__assign({}, transition), { event: eventType, delay: resolvedDelay })); });
            }));
        return delayedTransitions.map(function (delayedTransition) {
            var delay = delayedTransition.delay;
            return __assign(__assign({}, _this.formatTransition(delayedTransition)), { delay: delay });
        });
    };
    /**
     * Returns the state nodes represented by the current state value.
     *
     * @param state The state value or State instance
     */
    StateNode.prototype.getStateNodes = function (state) {
        var _a;
        var _this = this;
        if (!state) {
            return [];
        }
        var stateValue = state instanceof State_1.State
            ? state.value
            : utils_1.toStateValue(state, this.delimiter);
        if (utils_1.isString(stateValue)) {
            var initialStateValue = this.getStateNode(stateValue).initial;
            return initialStateValue !== undefined
                ? this.getStateNodes((_a = {}, _a[stateValue] = initialStateValue, _a))
                : [this.states[stateValue]];
        }
        var subStateKeys = utils_1.keys(stateValue);
        var subStateNodes = subStateKeys.map(function (subStateKey) { return _this.getStateNode(subStateKey); });
        return subStateNodes.concat(subStateKeys.reduce(function (allSubStateNodes, subStateKey) {
            var subStateNode = _this.getStateNode(subStateKey).getStateNodes(stateValue[subStateKey]);
            return allSubStateNodes.concat(subStateNode);
        }, []));
    };
    /**
     * Returns `true` if this state node explicitly handles the given event.
     *
     * @param event The event in question
     */
    StateNode.prototype.handles = function (event) {
        var eventType = utils_1.getEventType(event);
        return this.events.includes(eventType);
    };
    /**
     * Resolves the given `state` to a new `State` instance relative to this machine.
     *
     * This ensures that `.events` and `.nextEvents` represent the correct values.
     *
     * @param state The state to resolve
     */
    StateNode.prototype.resolveState = function (state) {
        var configuration = Array.from(stateUtils_1.getConfiguration([], this.getStateNodes(state.value)));
        return new State_1.State(__assign(__assign({}, state), { value: this.resolve(state.value), configuration: configuration, done: stateUtils_1.isInFinalState(configuration, this) }));
    };
    StateNode.prototype.transitionLeafNode = function (stateValue, state, _event) {
        var stateNode = this.getStateNode(stateValue);
        var next = stateNode.next(state, _event);
        if (!next || !next.transitions.length) {
            return this.next(state, _event);
        }
        return next;
    };
    StateNode.prototype.transitionCompoundNode = function (stateValue, state, _event) {
        var subStateKeys = utils_1.keys(stateValue);
        var stateNode = this.getStateNode(subStateKeys[0]);
        var next = stateNode._transition(stateValue[subStateKeys[0]], state, _event);
        if (!next || !next.transitions.length) {
            return this.next(state, _event);
        }
        return next;
    };
    StateNode.prototype.transitionParallelNode = function (stateValue, state, _event) {
        var e_2, _a;
        var transitionMap = {};
        try {
            for (var _b = __values(utils_1.keys(stateValue)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var subStateKey = _c.value;
                var subStateValue = stateValue[subStateKey];
                if (!subStateValue) {
                    continue;
                }
                var subStateNode = this.getStateNode(subStateKey);
                var next = subStateNode._transition(subStateValue, state, _event);
                if (next) {
                    transitionMap[subStateKey] = next;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        var stateTransitions = utils_1.keys(transitionMap).map(function (key) { return transitionMap[key]; });
        var enabledTransitions = utils_1.flatten(stateTransitions.map(function (st) { return st.transitions; }));
        var willTransition = stateTransitions.some(function (st) { return st.transitions.length > 0; });
        if (!willTransition) {
            return this.next(state, _event);
        }
        var entryNodes = utils_1.flatten(stateTransitions.map(function (t) { return t.entrySet; }));
        var configuration = utils_1.flatten(utils_1.keys(transitionMap).map(function (key) { return transitionMap[key].configuration; }));
        return {
            transitions: enabledTransitions,
            entrySet: entryNodes,
            exitSet: utils_1.flatten(stateTransitions.map(function (t) { return t.exitSet; })),
            configuration: configuration,
            source: state,
            actions: utils_1.flatten(utils_1.keys(transitionMap).map(function (key) {
                return transitionMap[key].actions;
            }))
        };
    };
    StateNode.prototype._transition = function (stateValue, state, _event) {
        // leaf node
        if (utils_1.isString(stateValue)) {
            return this.transitionLeafNode(stateValue, state, _event);
        }
        // hierarchical node
        if (utils_1.keys(stateValue).length === 1) {
            return this.transitionCompoundNode(stateValue, state, _event);
        }
        // orthogonal node
        return this.transitionParallelNode(stateValue, state, _event);
    };
    StateNode.prototype.next = function (state, _event) {
        var e_3, _a;
        var _this = this;
        var eventName = _event.name;
        var actions = [];
        var nextStateNodes = [];
        var selectedTransition;
        try {
            for (var _b = __values(this.getCandidates(eventName)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var candidate = _c.value;
                var cond = candidate.cond, stateIn = candidate.in;
                var resolvedContext = state.context;
                var isInState = stateIn
                    ? utils_1.isString(stateIn) && isStateId(stateIn)
                        ? // Check if in state by ID
                            state.matches(utils_1.toStateValue(this.getStateNodeById(stateIn).path, this.delimiter))
                        : // Check if in state by relative grandparent
                            utils_2.matchesState(utils_1.toStateValue(stateIn, this.delimiter), utils_1.path(this.path.slice(0, -2))(state.value))
                    : true;
                var guardPassed = false;
                try {
                    guardPassed =
                        !cond ||
                            utils_1.evaluateGuard(this.machine, cond, resolvedContext, _event, state);
                }
                catch (err) {
                    throw new Error("Unable to evaluate guard '" + (cond.name || cond.type) + "' in transition for event '" + eventName + "' in state node '" + this.id + "':\n" + err.message);
                }
                if (guardPassed && isInState) {
                    if (candidate.target !== undefined) {
                        nextStateNodes = candidate.target;
                    }
                    actions.push.apply(actions, __spread(candidate.actions));
                    selectedTransition = candidate;
                    break;
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        if (!selectedTransition) {
            return undefined;
        }
        if (!nextStateNodes.length) {
            return {
                transitions: [selectedTransition],
                entrySet: [],
                exitSet: [],
                configuration: state.value ? [this] : [],
                source: state,
                actions: actions
            };
        }
        var allNextStateNodes = utils_1.flatten(nextStateNodes.map(function (stateNode) {
            return _this.getRelativeStateNodes(stateNode, state.historyValue);
        }));
        var isInternal = !!selectedTransition.internal;
        var reentryNodes = isInternal
            ? []
            : utils_1.flatten(allNextStateNodes.map(function (n) { return _this.nodesFromChild(n); }));
        return {
            transitions: [selectedTransition],
            entrySet: reentryNodes,
            exitSet: isInternal ? [] : [this],
            configuration: allNextStateNodes,
            source: state,
            actions: actions
        };
    };
    StateNode.prototype.nodesFromChild = function (childStateNode) {
        if (childStateNode.escapes(this)) {
            return [];
        }
        var nodes = [];
        var marker = childStateNode;
        while (marker && marker !== this) {
            nodes.push(marker);
            marker = marker.parent;
        }
        nodes.push(this); // inclusive
        return nodes;
    };
    /**
     * Whether the given state node "escapes" this state node. If the `stateNode` is equal to or the parent of
     * this state node, it does not escape.
     */
    StateNode.prototype.escapes = function (stateNode) {
        if (this === stateNode) {
            return false;
        }
        var parent = this.parent;
        while (parent) {
            if (parent === stateNode) {
                return false;
            }
            parent = parent.parent;
        }
        return true;
    };
    StateNode.prototype.getActions = function (transition, currentContext, _event, prevState) {
        var e_4, _a, e_5, _b;
        var prevConfig = stateUtils_1.getConfiguration([], prevState ? this.getStateNodes(prevState.value) : [this]);
        var resolvedConfig = transition.configuration.length
            ? stateUtils_1.getConfiguration(prevConfig, transition.configuration)
            : prevConfig;
        try {
            for (var resolvedConfig_1 = __values(resolvedConfig), resolvedConfig_1_1 = resolvedConfig_1.next(); !resolvedConfig_1_1.done; resolvedConfig_1_1 = resolvedConfig_1.next()) {
                var sn = resolvedConfig_1_1.value;
                if (!stateUtils_1.has(prevConfig, sn)) {
                    transition.entrySet.push(sn);
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (resolvedConfig_1_1 && !resolvedConfig_1_1.done && (_a = resolvedConfig_1.return)) _a.call(resolvedConfig_1);
            }
            finally { if (e_4) throw e_4.error; }
        }
        try {
            for (var prevConfig_1 = __values(prevConfig), prevConfig_1_1 = prevConfig_1.next(); !prevConfig_1_1.done; prevConfig_1_1 = prevConfig_1.next()) {
                var sn = prevConfig_1_1.value;
                if (!stateUtils_1.has(resolvedConfig, sn) || stateUtils_1.has(transition.exitSet, sn.parent)) {
                    transition.exitSet.push(sn);
                }
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (prevConfig_1_1 && !prevConfig_1_1.done && (_b = prevConfig_1.return)) _b.call(prevConfig_1);
            }
            finally { if (e_5) throw e_5.error; }
        }
        if (!transition.source) {
            transition.exitSet = [];
            // Ensure that root StateNode (machine) is entered
            transition.entrySet.push(this);
        }
        var doneEvents = utils_1.flatten(transition.entrySet.map(function (sn) {
            var events = [];
            if (sn.type !== 'final') {
                return events;
            }
            var parent = sn.parent;
            if (!parent.parent) {
                return events;
            }
            events.push(actions_1.done(sn.id, sn.doneData), // TODO: deprecate - final states should not emit done events for their own state.
            actions_1.done(parent.id, sn.doneData
                ? utils_1.mapContext(sn.doneData, currentContext, _event)
                : undefined));
            var grandparent = parent.parent;
            if (grandparent.type === 'parallel') {
                if (stateUtils_1.getChildren(grandparent).every(function (parentNode) {
                    return stateUtils_1.isInFinalState(transition.configuration, parentNode);
                })) {
                    events.push(actions_1.done(grandparent.id));
                }
            }
            return events;
        }));
        transition.exitSet.sort(function (a, b) { return b.order - a.order; });
        transition.entrySet.sort(function (a, b) { return a.order - b.order; });
        var entryStates = new Set(transition.entrySet);
        var exitStates = new Set(transition.exitSet);
        var _c = __read([
            utils_1.flatten(Array.from(entryStates).map(function (stateNode) {
                return __spread(stateNode.activities.map(function (activity) { return actions_1.start(activity); }), stateNode.onEntry);
            })).concat(doneEvents.map(actions_1.raise)),
            utils_1.flatten(Array.from(exitStates).map(function (stateNode) { return __spread(stateNode.onExit, stateNode.activities.map(function (activity) { return actions_1.stop(activity); })); }))
        ], 2), entryActions = _c[0], exitActions = _c[1];
        var actions = actions_1.toActionObjects(exitActions.concat(transition.actions).concat(entryActions), this.machine.options.actions);
        return actions;
    };
    /**
     * Determines the next state given the current `state` and sent `event`.
     *
     * @param state The current State instance or state value
     * @param event The event that was sent at the current state
     * @param context The current context (extended state) of the current state
     */
    StateNode.prototype.transition = function (state, event, context) {
        if (state === void 0) { state = this
            .initialState; }
        var _event = utils_1.toSCXMLEvent(event);
        var currentState;
        if (state instanceof State_1.State) {
            currentState =
                context === undefined
                    ? state
                    : this.resolveState(State_1.State.from(state, context));
        }
        else {
            var resolvedStateValue = utils_1.isString(state)
                ? this.resolve(utils_1.pathToStateValue(this.getResolvedPath(state)))
                : this.resolve(state);
            var resolvedContext = context ? context : this.machine.context;
            currentState = this.resolveState(State_1.State.from(resolvedStateValue, resolvedContext));
        }
        if (!environment_1.IS_PRODUCTION && _event.name === WILDCARD) {
            throw new Error("An event cannot have the wildcard type ('" + WILDCARD + "')");
        }
        if (this.strict) {
            if (!this.events.includes(_event.name) && !utils_1.isBuiltInEvent(_event.name)) {
                throw new Error("Machine '" + this.id + "' does not accept event '" + _event.name + "'");
            }
        }
        var stateTransition = this._transition(currentState.value, currentState, _event) || {
            transitions: [],
            configuration: [],
            entrySet: [],
            exitSet: [],
            source: currentState,
            actions: []
        };
        var prevConfig = stateUtils_1.getConfiguration([], this.getStateNodes(currentState.value));
        var resolvedConfig = stateTransition.configuration.length
            ? stateUtils_1.getConfiguration(prevConfig, stateTransition.configuration)
            : prevConfig;
        stateTransition.configuration = __spread(resolvedConfig);
        return this.resolveTransition(stateTransition, currentState, _event);
    };
    StateNode.prototype.resolveRaisedTransition = function (state, _event, originalEvent) {
        var _a;
        var currentActions = state.actions;
        state = this.transition(state, _event);
        // Save original event to state
        // TODO: this should be the raised event! Delete in V5 (breaking)
        state._event = originalEvent;
        state.event = originalEvent.data;
        (_a = state.actions).unshift.apply(_a, __spread(currentActions));
        return state;
    };
    StateNode.prototype.resolveTransition = function (stateTransition, currentState, _event, context) {
        var e_6, _a;
        var _this = this;
        if (_event === void 0) { _event = actions_1.initEvent; }
        if (context === void 0) { context = this.machine.context; }
        var configuration = stateTransition.configuration;
        // Transition will "apply" if:
        // - this is the initial state (there is no current state)
        // - OR there are transitions
        var willTransition = !currentState || stateTransition.transitions.length > 0;
        var resolvedStateValue = willTransition
            ? stateUtils_1.getValue(this.machine, configuration)
            : undefined;
        var historyValue = currentState
            ? currentState.historyValue
                ? currentState.historyValue
                : stateTransition.source
                    ? this.machine.historyValue(currentState.value)
                    : undefined
            : undefined;
        var currentContext = currentState ? currentState.context : context;
        var actions = this.getActions(stateTransition, currentContext, _event, currentState);
        var activities = currentState ? __assign({}, currentState.activities) : {};
        try {
            for (var actions_2 = __values(actions), actions_2_1 = actions_2.next(); !actions_2_1.done; actions_2_1 = actions_2.next()) {
                var action = actions_2_1.value;
                if (action.type === actionTypes.start) {
                    activities[action.activity.id || action.activity.type] = action;
                }
                else if (action.type === actionTypes.stop) {
                    activities[action.activity.id || action.activity.type] = false;
                }
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (actions_2_1 && !actions_2_1.done && (_a = actions_2.return)) _a.call(actions_2);
            }
            finally { if (e_6) throw e_6.error; }
        }
        var _b = __read(actions_1.resolveActions(this, currentState, currentContext, _event, actions), 2), resolvedActions = _b[0], updatedContext = _b[1];
        var _c = __read(utils_1.partition(resolvedActions, function (action) {
            return action.type === actionTypes.raise ||
                (action.type === actionTypes.send &&
                    action.to ===
                        types_1.SpecialTargets.Internal);
        }), 2), raisedEvents = _c[0], nonRaisedActions = _c[1];
        var invokeActions = resolvedActions.filter(function (action) {
            var _a;
            return (action.type === actionTypes.start &&
                ((_a = action.activity) === null || _a === void 0 ? void 0 : _a.type) ===
                    actionTypes.invoke);
        });
        var children = invokeActions.reduce(function (acc, action) {
            acc[action.activity.id] = Actor_1.createInvocableActor(action.activity, _this.machine, updatedContext, _event);
            return acc;
        }, currentState
            ? __assign({}, currentState.children) : {});
        var resolvedConfiguration = resolvedStateValue
            ? stateTransition.configuration
            : currentState
                ? currentState.configuration
                : [];
        var meta = resolvedConfiguration.reduce(function (acc, stateNode) {
            if (stateNode.meta !== undefined) {
                acc[stateNode.id] = stateNode.meta;
            }
            return acc;
        }, {});
        var isDone = stateUtils_1.isInFinalState(resolvedConfiguration, this);
        var nextState = new State_1.State({
            value: resolvedStateValue || currentState.value,
            context: updatedContext,
            _event: _event,
            // Persist _sessionid between states
            _sessionid: currentState ? currentState._sessionid : null,
            historyValue: resolvedStateValue
                ? historyValue
                    ? utils_1.updateHistoryValue(historyValue, resolvedStateValue)
                    : undefined
                : currentState
                    ? currentState.historyValue
                    : undefined,
            history: !resolvedStateValue || stateTransition.source
                ? currentState
                : undefined,
            actions: resolvedStateValue ? nonRaisedActions : [],
            activities: resolvedStateValue
                ? activities
                : currentState
                    ? currentState.activities
                    : {},
            meta: resolvedStateValue
                ? meta
                : currentState
                    ? currentState.meta
                    : undefined,
            events: [],
            configuration: resolvedConfiguration,
            transitions: stateTransition.transitions,
            children: children,
            done: isDone
        });
        var didUpdateContext = currentContext !== updatedContext;
        nextState.changed = _event.name === actionTypes.update || didUpdateContext;
        // Dispose of penultimate histories to prevent memory leaks
        var history = nextState.history;
        if (history) {
            delete history.history;
        }
        if (!resolvedStateValue) {
            return nextState;
        }
        var maybeNextState = nextState;
        if (!isDone) {
            var isTransient = this._transient ||
                configuration.some(function (stateNode) {
                    return stateNode._transient;
                });
            if (isTransient) {
                maybeNextState = this.resolveRaisedTransition(maybeNextState, {
                    type: actionTypes.nullEvent
                }, _event);
            }
            while (raisedEvents.length) {
                var raisedEvent = raisedEvents.shift();
                maybeNextState = this.resolveRaisedTransition(maybeNextState, raisedEvent._event, _event);
            }
        }
        // Detect if state changed
        var changed = maybeNextState.changed ||
            (history
                ? !!maybeNextState.actions.length ||
                    didUpdateContext ||
                    typeof history.value !== typeof maybeNextState.value ||
                    !State_1.stateValuesEqual(maybeNextState.value, history.value)
                : undefined);
        maybeNextState.changed = changed;
        // Preserve original history after raised events
        maybeNextState.history = history;
        return maybeNextState;
    };
    /**
     * Returns the child state node from its relative `stateKey`, or throws.
     */
    StateNode.prototype.getStateNode = function (stateKey) {
        if (isStateId(stateKey)) {
            return this.machine.getStateNodeById(stateKey);
        }
        if (!this.states) {
            throw new Error("Unable to retrieve child state '" + stateKey + "' from '" + this.id + "'; no child states exist.");
        }
        var result = this.states[stateKey];
        if (!result) {
            throw new Error("Child state '" + stateKey + "' does not exist on '" + this.id + "'");
        }
        return result;
    };
    /**
     * Returns the state node with the given `stateId`, or throws.
     *
     * @param stateId The state ID. The prefix "#" is removed.
     */
    StateNode.prototype.getStateNodeById = function (stateId) {
        var resolvedStateId = isStateId(stateId)
            ? stateId.slice(STATE_IDENTIFIER.length)
            : stateId;
        if (resolvedStateId === this.id) {
            return this;
        }
        var stateNode = this.machine.idMap[resolvedStateId];
        if (!stateNode) {
            throw new Error("Child state node '#" + resolvedStateId + "' does not exist on machine '" + this.id + "'");
        }
        return stateNode;
    };
    /**
     * Returns the relative state node from the given `statePath`, or throws.
     *
     * @param statePath The string or string array relative path to the state node.
     */
    StateNode.prototype.getStateNodeByPath = function (statePath) {
        if (typeof statePath === 'string' && isStateId(statePath)) {
            try {
                return this.getStateNodeById(statePath.slice(1));
            }
            catch (e) {
                // try individual paths
                // throw e;
            }
        }
        var arrayStatePath = utils_1.toStatePath(statePath, this.delimiter).slice();
        var currentStateNode = this;
        while (arrayStatePath.length) {
            var key = arrayStatePath.shift();
            if (!key.length) {
                break;
            }
            currentStateNode = currentStateNode.getStateNode(key);
        }
        return currentStateNode;
    };
    /**
     * Resolves a partial state value with its full representation in this machine.
     *
     * @param stateValue The partial state value to resolve.
     */
    StateNode.prototype.resolve = function (stateValue) {
        var _a;
        var _this = this;
        if (!stateValue) {
            return this.initialStateValue || EMPTY_OBJECT; // TODO: type-specific properties
        }
        switch (this.type) {
            case 'parallel':
                return utils_1.mapValues(this.initialStateValue, function (subStateValue, subStateKey) {
                    return subStateValue
                        ? _this.getStateNode(subStateKey).resolve(stateValue[subStateKey] || subStateValue)
                        : EMPTY_OBJECT;
                });
            case 'compound':
                if (utils_1.isString(stateValue)) {
                    var subStateNode = this.getStateNode(stateValue);
                    if (subStateNode.type === 'parallel' ||
                        subStateNode.type === 'compound') {
                        return _a = {}, _a[stateValue] = subStateNode.initialStateValue, _a;
                    }
                    return stateValue;
                }
                if (!utils_1.keys(stateValue).length) {
                    return this.initialStateValue || {};
                }
                return utils_1.mapValues(stateValue, function (subStateValue, subStateKey) {
                    return subStateValue
                        ? _this.getStateNode(subStateKey).resolve(subStateValue)
                        : EMPTY_OBJECT;
                });
            default:
                return stateValue || EMPTY_OBJECT;
        }
    };
    StateNode.prototype.getResolvedPath = function (stateIdentifier) {
        if (isStateId(stateIdentifier)) {
            var stateNode = this.machine.idMap[stateIdentifier.slice(STATE_IDENTIFIER.length)];
            if (!stateNode) {
                throw new Error("Unable to find state node '" + stateIdentifier + "'");
            }
            return stateNode.path;
        }
        return utils_1.toStatePath(stateIdentifier, this.delimiter);
    };
    Object.defineProperty(StateNode.prototype, "initialStateValue", {
        get: function () {
            var _a;
            if (this.__cache.initialStateValue) {
                return this.__cache.initialStateValue;
            }
            var initialStateValue;
            if (this.type === 'parallel') {
                initialStateValue = utils_1.mapFilterValues(this.states, function (state) { return state.initialStateValue || EMPTY_OBJECT; }, function (stateNode) { return !(stateNode.type === 'history'); });
            }
            else if (this.initial !== undefined) {
                if (!this.states[this.initial]) {
                    throw new Error("Initial state '" + this.initial + "' not found on '" + this.key + "'");
                }
                initialStateValue = (stateUtils_1.isLeafNode(this.states[this.initial])
                    ? this.initial
                    : (_a = {},
                        _a[this.initial] = this.states[this.initial].initialStateValue,
                        _a));
            }
            this.__cache.initialStateValue = initialStateValue;
            return this.__cache.initialStateValue;
        },
        enumerable: false,
        configurable: true
    });
    StateNode.prototype.getInitialState = function (stateValue, context) {
        var configuration = this.getStateNodes(stateValue);
        return this.resolveTransition({
            configuration: configuration,
            entrySet: configuration,
            exitSet: [],
            transitions: [],
            source: undefined,
            actions: []
        }, undefined, undefined, context);
    };
    Object.defineProperty(StateNode.prototype, "initialState", {
        /**
         * The initial State instance, which includes all actions to be executed from
         * entering the initial state.
         */
        get: function () {
            this._init(); // TODO: this should be in the constructor (see note in constructor)
            var initialStateValue = this.initialStateValue;
            if (!initialStateValue) {
                throw new Error("Cannot retrieve initial state from simple state '" + this.id + "'.");
            }
            return this.getInitialState(initialStateValue);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StateNode.prototype, "target", {
        /**
         * The target state value of the history state node, if it exists. This represents the
         * default state value to transition to if no history value exists yet.
         */
        get: function () {
            var target;
            if (this.type === 'history') {
                var historyConfig = this.config;
                if (utils_1.isString(historyConfig.target)) {
                    target = isStateId(historyConfig.target)
                        ? utils_1.pathToStateValue(this.machine
                            .getStateNodeById(historyConfig.target)
                            .path.slice(this.path.length - 1))
                        : historyConfig.target;
                }
                else {
                    target = historyConfig.target;
                }
            }
            return target;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns the leaf nodes from a state path relative to this state node.
     *
     * @param relativeStateId The relative state path to retrieve the state nodes
     * @param history The previous state to retrieve history
     * @param resolve Whether state nodes should resolve to initial child state nodes
     */
    StateNode.prototype.getRelativeStateNodes = function (relativeStateId, historyValue, resolve) {
        if (resolve === void 0) { resolve = true; }
        return resolve
            ? relativeStateId.type === 'history'
                ? relativeStateId.resolveHistory(historyValue)
                : relativeStateId.initialStateNodes
            : [relativeStateId];
    };
    Object.defineProperty(StateNode.prototype, "initialStateNodes", {
        get: function () {
            var _this = this;
            if (stateUtils_1.isLeafNode(this)) {
                return [this];
            }
            // Case when state node is compound but no initial state is defined
            if (this.type === 'compound' && !this.initial) {
                if (!environment_1.IS_PRODUCTION) {
                    utils_1.warn(false, "Compound state node '" + this.id + "' has no initial state.");
                }
                return [this];
            }
            var initialStateNodePaths = utils_1.toStatePaths(this.initialStateValue);
            return utils_1.flatten(initialStateNodePaths.map(function (initialPath) {
                return _this.getFromRelativePath(initialPath);
            }));
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Retrieves state nodes from a relative path to this state node.
     *
     * @param relativePath The relative path from this state node
     * @param historyValue
     */
    StateNode.prototype.getFromRelativePath = function (relativePath) {
        if (!relativePath.length) {
            return [this];
        }
        var _a = __read(relativePath), stateKey = _a[0], childStatePath = _a.slice(1);
        if (!this.states) {
            throw new Error("Cannot retrieve subPath '" + stateKey + "' from node with no states");
        }
        var childStateNode = this.getStateNode(stateKey);
        if (childStateNode.type === 'history') {
            return childStateNode.resolveHistory();
        }
        if (!this.states[stateKey]) {
            throw new Error("Child state '" + stateKey + "' does not exist on '" + this.id + "'");
        }
        return this.states[stateKey].getFromRelativePath(childStatePath);
    };
    StateNode.prototype.historyValue = function (relativeStateValue) {
        if (!utils_1.keys(this.states).length) {
            return undefined;
        }
        return {
            current: relativeStateValue || this.initialStateValue,
            states: utils_1.mapFilterValues(this.states, function (stateNode, key) {
                if (!relativeStateValue) {
                    return stateNode.historyValue();
                }
                var subStateValue = utils_1.isString(relativeStateValue)
                    ? undefined
                    : relativeStateValue[key];
                return stateNode.historyValue(subStateValue || stateNode.initialStateValue);
            }, function (stateNode) { return !stateNode.history; })
        };
    };
    /**
     * Resolves to the historical value(s) of the parent state node,
     * represented by state nodes.
     *
     * @param historyValue
     */
    StateNode.prototype.resolveHistory = function (historyValue) {
        var _this = this;
        if (this.type !== 'history') {
            return [this];
        }
        var parent = this.parent;
        if (!historyValue) {
            var historyTarget = this.target;
            return historyTarget
                ? utils_1.flatten(utils_1.toStatePaths(historyTarget).map(function (relativeChildPath) {
                    return parent.getFromRelativePath(relativeChildPath);
                }))
                : parent.initialStateNodes;
        }
        var subHistoryValue = utils_1.nestedPath(parent.path, 'states')(historyValue).current;
        if (utils_1.isString(subHistoryValue)) {
            return [parent.getStateNode(subHistoryValue)];
        }
        return utils_1.flatten(utils_1.toStatePaths(subHistoryValue).map(function (subStatePath) {
            return _this.history === 'deep'
                ? parent.getFromRelativePath(subStatePath)
                : [parent.states[subStatePath[0]]];
        }));
    };
    Object.defineProperty(StateNode.prototype, "stateIds", {
        /**
         * All the state node IDs of this state node and its descendant state nodes.
         */
        get: function () {
            var _this = this;
            var childStateIds = utils_1.flatten(utils_1.keys(this.states).map(function (stateKey) {
                return _this.states[stateKey].stateIds;
            }));
            return [this.id].concat(childStateIds);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StateNode.prototype, "events", {
        /**
         * All the event types accepted by this state node and its descendants.
         */
        get: function () {
            var e_7, _a, e_8, _b;
            if (this.__cache.events) {
                return this.__cache.events;
            }
            var states = this.states;
            var events = new Set(this.ownEvents);
            if (states) {
                try {
                    for (var _c = __values(utils_1.keys(states)), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var stateId = _d.value;
                        var state = states[stateId];
                        if (state.states) {
                            try {
                                for (var _e = (e_8 = void 0, __values(state.events)), _f = _e.next(); !_f.done; _f = _e.next()) {
                                    var event_1 = _f.value;
                                    events.add("" + event_1);
                                }
                            }
                            catch (e_8_1) { e_8 = { error: e_8_1 }; }
                            finally {
                                try {
                                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                                }
                                finally { if (e_8) throw e_8.error; }
                            }
                        }
                    }
                }
                catch (e_7_1) { e_7 = { error: e_7_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                    }
                    finally { if (e_7) throw e_7.error; }
                }
            }
            return (this.__cache.events = Array.from(events));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StateNode.prototype, "ownEvents", {
        /**
         * All the events that have transitions directly from this state node.
         *
         * Excludes any inert events.
         */
        get: function () {
            var events = new Set(this.transitions
                .filter(function (transition) {
                return !(!transition.target &&
                    !transition.actions.length &&
                    transition.internal);
            })
                .map(function (transition) { return transition.eventType; }));
            return Array.from(events);
        },
        enumerable: false,
        configurable: true
    });
    StateNode.prototype.resolveTarget = function (_target) {
        var _this = this;
        if (_target === undefined) {
            // an undefined target signals that the state node should not transition from that state when receiving that event
            return undefined;
        }
        return _target.map(function (target) {
            if (!utils_1.isString(target)) {
                return target;
            }
            var isInternalTarget = target[0] === _this.delimiter;
            // If internal target is defined on machine,
            // do not include machine key on target
            if (isInternalTarget && !_this.parent) {
                return _this.getStateNodeByPath(target.slice(1));
            }
            var resolvedTarget = isInternalTarget ? _this.key + target : target;
            if (_this.parent) {
                try {
                    var targetStateNode = _this.parent.getStateNodeByPath(resolvedTarget);
                    return targetStateNode;
                }
                catch (err) {
                    throw new Error("Invalid transition definition for state node '" + _this.id + "':\n" + err.message);
                }
            }
            else {
                return _this.getStateNodeByPath(resolvedTarget);
            }
        });
    };
    StateNode.prototype.formatTransition = function (transitionConfig) {
        var _this = this;
        var normalizedTarget = utils_1.normalizeTarget(transitionConfig.target);
        var internal = 'internal' in transitionConfig
            ? transitionConfig.internal
            : normalizedTarget
                ? normalizedTarget.some(function (_target) { return utils_1.isString(_target) && _target[0] === _this.delimiter; })
                : true;
        var guards = this.machine.options.guards;
        var target = this.resolveTarget(normalizedTarget);
        var transition = __assign(__assign({}, transitionConfig), { actions: actions_1.toActionObjects(utils_1.toArray(transitionConfig.actions)), cond: utils_1.toGuard(transitionConfig.cond, guards), target: target, source: this, internal: internal, eventType: transitionConfig.event, toJSON: function () { return (__assign(__assign({}, transition), { target: transition.target
                    ? transition.target.map(function (t) { return "#" + t.id; })
                    : undefined, source: "#" + _this.id })); } });
        return transition;
    };
    StateNode.prototype.formatTransitions = function () {
        var e_9, _a;
        var _this = this;
        var onConfig;
        if (!this.config.on) {
            onConfig = [];
        }
        else if (Array.isArray(this.config.on)) {
            onConfig = this.config.on;
        }
        else {
            var _b = this.config.on, _c = WILDCARD, _d = _b[_c], wildcardConfigs = _d === void 0 ? [] : _d, strictTransitionConfigs_1 = __rest(_b, [typeof _c === "symbol" ? _c : _c + ""]);
            onConfig = utils_1.flatten(utils_1.keys(strictTransitionConfigs_1)
                .map(function (key) {
                if (!environment_1.IS_PRODUCTION && key === NULL_EVENT) {
                    utils_1.warn(false, "Empty string transition configs (e.g., `{ on: { '': ... }}`) for transient transitions are deprecated. Specify the transition in the `{ always: ... }` property instead. " +
                        ("Please check the `on` configuration for \"#" + _this.id + "\"."));
                }
                var transitionConfigArray = utils_1.toTransitionConfigArray(key, strictTransitionConfigs_1[key]);
                if (!environment_1.IS_PRODUCTION) {
                    validateArrayifiedTransitions(_this, key, transitionConfigArray);
                }
                return transitionConfigArray;
            })
                .concat(utils_1.toTransitionConfigArray(WILDCARD, wildcardConfigs)));
        }
        var eventlessConfig = this.config.always
            ? utils_1.toTransitionConfigArray('', this.config.always)
            : [];
        var doneConfig = this.config.onDone
            ? utils_1.toTransitionConfigArray(String(actions_1.done(this.id)), this.config.onDone)
            : [];
        if (!environment_1.IS_PRODUCTION) {
            utils_1.warn(!(this.config.onDone && !this.parent), "Root nodes cannot have an \".onDone\" transition. Please check the config of \"" + this.id + "\".");
        }
        var invokeConfig = utils_1.flatten(this.invoke.map(function (invokeDef) {
            var settleTransitions = [];
            if (invokeDef.onDone) {
                settleTransitions.push.apply(settleTransitions, __spread(utils_1.toTransitionConfigArray(String(actions_1.doneInvoke(invokeDef.id)), invokeDef.onDone)));
            }
            if (invokeDef.onError) {
                settleTransitions.push.apply(settleTransitions, __spread(utils_1.toTransitionConfigArray(String(actions_1.error(invokeDef.id)), invokeDef.onError)));
            }
            return settleTransitions;
        }));
        var delayedTransitions = this.after;
        var formattedTransitions = utils_1.flatten(__spread(doneConfig, invokeConfig, onConfig, eventlessConfig).map(function (transitionConfig) {
            return utils_1.toArray(transitionConfig).map(function (transition) {
                return _this.formatTransition(transition);
            });
        }));
        try {
            for (var delayedTransitions_1 = __values(delayedTransitions), delayedTransitions_1_1 = delayedTransitions_1.next(); !delayedTransitions_1_1.done; delayedTransitions_1_1 = delayedTransitions_1.next()) {
                var delayedTransition = delayedTransitions_1_1.value;
                formattedTransitions.push(delayedTransition);
            }
        }
        catch (e_9_1) { e_9 = { error: e_9_1 }; }
        finally {
            try {
                if (delayedTransitions_1_1 && !delayedTransitions_1_1.done && (_a = delayedTransitions_1.return)) _a.call(delayedTransitions_1);
            }
            finally { if (e_9) throw e_9.error; }
        }
        return formattedTransitions;
    };
    return StateNode;
}());
exports.StateNode = StateNode;

},{"./utils":"e5f04d71d69884b4184956b7ea1c2036","./types":"c548ffd845c55f4fd347026b8ab58cb7","./State":"fa8df89fc69b67a2024e57052242dafb","./actionTypes":"b37dca994227f949b5b489aadf8f0f92","./actions":"5adc8f58799118d0329ab2c28b9ab1b1","./environment":"6dbe9637d67ccc4648d820c8714c7766","./constants":"60ce741ac53d1e94aa8807a548293ad5","./stateUtils":"ae25440d22bedacc42657db575bb3ca7","./Actor":"ebbbf0386563f93a004a28c3b372cf9b","./invokeUtils":"00b072b1a9d46c3e41491664fc951421"}],"c548ffd845c55f4fd347026b8ab58cb7":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpecialTargets = exports.ActionTypes = void 0;
var ActionTypes;
(function (ActionTypes) {
    ActionTypes["Start"] = "xstate.start";
    ActionTypes["Stop"] = "xstate.stop";
    ActionTypes["Raise"] = "xstate.raise";
    ActionTypes["Send"] = "xstate.send";
    ActionTypes["Cancel"] = "xstate.cancel";
    ActionTypes["NullEvent"] = "";
    ActionTypes["Assign"] = "xstate.assign";
    ActionTypes["After"] = "xstate.after";
    ActionTypes["DoneState"] = "done.state";
    ActionTypes["DoneInvoke"] = "done.invoke";
    ActionTypes["Log"] = "xstate.log";
    ActionTypes["Init"] = "xstate.init";
    ActionTypes["Invoke"] = "xstate.invoke";
    ActionTypes["ErrorExecution"] = "error.execution";
    ActionTypes["ErrorCommunication"] = "error.communication";
    ActionTypes["ErrorPlatform"] = "error.platform";
    ActionTypes["ErrorCustom"] = "xstate.error";
    ActionTypes["Update"] = "xstate.update";
    ActionTypes["Pure"] = "xstate.pure";
    ActionTypes["Choose"] = "xstate.choose";
})(ActionTypes = exports.ActionTypes || (exports.ActionTypes = {}));
var SpecialTargets;
(function (SpecialTargets) {
    SpecialTargets["Parent"] = "#_parent";
    SpecialTargets["Internal"] = "#_internal";
})(SpecialTargets = exports.SpecialTargets || (exports.SpecialTargets = {}));

},{}],"fa8df89fc69b67a2024e57052242dafb":[function(require,module,exports) {
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.State = exports.bindActionToState = exports.isState = exports.stateValuesEqual = void 0;
var constants_1 = require("./constants");
var utils_1 = require("./utils");
var stateUtils_1 = require("./stateUtils");
var actions_1 = require("./actions");
function stateValuesEqual(a, b) {
    if (a === b) {
        return true;
    }
    if (a === undefined || b === undefined) {
        return false;
    }
    if (utils_1.isString(a) || utils_1.isString(b)) {
        return a === b;
    }
    var aKeys = utils_1.keys(a);
    var bKeys = utils_1.keys(b);
    return (aKeys.length === bKeys.length &&
        aKeys.every(function (key) { return stateValuesEqual(a[key], b[key]); }));
}
exports.stateValuesEqual = stateValuesEqual;
function isState(state) {
    if (utils_1.isString(state)) {
        return false;
    }
    return 'value' in state && 'history' in state;
}
exports.isState = isState;
function bindActionToState(action, state) {
    var exec = action.exec;
    var boundAction = __assign(__assign({}, action), { exec: exec !== undefined
            ? function () {
                return exec(state.context, state.event, {
                    action: action,
                    state: state,
                    _event: state._event
                });
            }
            : undefined });
    return boundAction;
}
exports.bindActionToState = bindActionToState;
var State = /** @class */ (function () {
    /**
     * Creates a new State instance.
     * @param value The state value
     * @param context The extended state
     * @param historyValue The tree representing historical values of the state nodes
     * @param history The previous state
     * @param actions An array of action objects to execute as side-effects
     * @param activities A mapping of activities and whether they are started (`true`) or stopped (`false`).
     * @param meta
     * @param events Internal event queue. Should be empty with run-to-completion semantics.
     * @param configuration
     */
    function State(config) {
        var _this = this;
        this.actions = [];
        this.activities = constants_1.EMPTY_ACTIVITY_MAP;
        this.meta = {};
        this.events = [];
        this.value = config.value;
        this.context = config.context;
        this._event = config._event;
        this._sessionid = config._sessionid;
        this.event = this._event.data;
        this.historyValue = config.historyValue;
        this.history = config.history;
        this.actions = config.actions || [];
        this.activities = config.activities || constants_1.EMPTY_ACTIVITY_MAP;
        this.meta = config.meta || {};
        this.events = config.events || [];
        this.matches = this.matches.bind(this);
        this.toStrings = this.toStrings.bind(this);
        this.configuration = config.configuration;
        this.transitions = config.transitions;
        this.children = config.children;
        this.done = !!config.done;
        Object.defineProperty(this, 'nextEvents', {
            get: function () {
                return stateUtils_1.nextEvents(_this.configuration);
            }
        });
    }
    /**
     * Creates a new State instance for the given `stateValue` and `context`.
     * @param stateValue
     * @param context
     */
    State.from = function (stateValue, context) {
        if (stateValue instanceof State) {
            if (stateValue.context !== context) {
                return new State({
                    value: stateValue.value,
                    context: context,
                    _event: stateValue._event,
                    _sessionid: null,
                    historyValue: stateValue.historyValue,
                    history: stateValue.history,
                    actions: [],
                    activities: stateValue.activities,
                    meta: {},
                    events: [],
                    configuration: [],
                    transitions: [],
                    children: {}
                });
            }
            return stateValue;
        }
        var _event = actions_1.initEvent;
        return new State({
            value: stateValue,
            context: context,
            _event: _event,
            _sessionid: null,
            historyValue: undefined,
            history: undefined,
            actions: [],
            activities: undefined,
            meta: undefined,
            events: [],
            configuration: [],
            transitions: [],
            children: {}
        });
    };
    /**
     * Creates a new State instance for the given `config`.
     * @param config The state config
     */
    State.create = function (config) {
        return new State(config);
    };
    /**
     * Creates a new `State` instance for the given `stateValue` and `context` with no actions (side-effects).
     * @param stateValue
     * @param context
     */
    State.inert = function (stateValue, context) {
        if (stateValue instanceof State) {
            if (!stateValue.actions.length) {
                return stateValue;
            }
            var _event = actions_1.initEvent;
            return new State({
                value: stateValue.value,
                context: context,
                _event: _event,
                _sessionid: null,
                historyValue: stateValue.historyValue,
                history: stateValue.history,
                activities: stateValue.activities,
                configuration: stateValue.configuration,
                transitions: [],
                children: {}
            });
        }
        return State.from(stateValue, context);
    };
    /**
     * Returns an array of all the string leaf state node paths.
     * @param stateValue
     * @param delimiter The character(s) that separate each subpath in the string state node path.
     */
    State.prototype.toStrings = function (stateValue, delimiter) {
        var _this = this;
        if (stateValue === void 0) { stateValue = this.value; }
        if (delimiter === void 0) { delimiter = '.'; }
        if (utils_1.isString(stateValue)) {
            return [stateValue];
        }
        var valueKeys = utils_1.keys(stateValue);
        return valueKeys.concat.apply(valueKeys, __spread(valueKeys.map(function (key) {
            return _this.toStrings(stateValue[key], delimiter).map(function (s) { return key + delimiter + s; });
        })));
    };
    State.prototype.toJSON = function () {
        var _a = this, configuration = _a.configuration, transitions = _a.transitions, jsonValues = __rest(_a, ["configuration", "transitions"]);
        return jsonValues;
    };
    /**
     * Whether the current state value is a subset of the given parent state value.
     * @param parentStateValue
     */
    State.prototype.matches = function (parentStateValue) {
        return utils_1.matchesState(parentStateValue, this.value);
    };
    return State;
}());
exports.State = State;

},{"./constants":"60ce741ac53d1e94aa8807a548293ad5","./utils":"e5f04d71d69884b4184956b7ea1c2036","./stateUtils":"ae25440d22bedacc42657db575bb3ca7","./actions":"5adc8f58799118d0329ab2c28b9ab1b1"}],"ae25440d22bedacc42657db575bb3ca7":[function(require,module,exports) {
"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isInFinalState = exports.nextEvents = exports.has = exports.getValue = exports.getAdjList = exports.getConfiguration = exports.getAllStateNodes = exports.getChildren = exports.isLeafNode = void 0;
var utils_1 = require("./utils");
var isLeafNode = function (stateNode) {
    return stateNode.type === 'atomic' || stateNode.type === 'final';
};
exports.isLeafNode = isLeafNode;
function getChildren(stateNode) {
    return utils_1.keys(stateNode.states).map(function (key) { return stateNode.states[key]; });
}
exports.getChildren = getChildren;
function getAllStateNodes(stateNode) {
    var stateNodes = [stateNode];
    if (exports.isLeafNode(stateNode)) {
        return stateNodes;
    }
    return stateNodes.concat(utils_1.flatten(getChildren(stateNode).map(getAllStateNodes)));
}
exports.getAllStateNodes = getAllStateNodes;
function getConfiguration(prevStateNodes, stateNodes) {
    var e_1, _a, e_2, _b, e_3, _c, e_4, _d;
    var prevConfiguration = new Set(prevStateNodes);
    var prevAdjList = getAdjList(prevConfiguration);
    var configuration = new Set(stateNodes);
    try {
        // add all ancestors
        for (var configuration_1 = __values(configuration), configuration_1_1 = configuration_1.next(); !configuration_1_1.done; configuration_1_1 = configuration_1.next()) {
            var s = configuration_1_1.value;
            var m = s.parent;
            while (m && !configuration.has(m)) {
                configuration.add(m);
                m = m.parent;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (configuration_1_1 && !configuration_1_1.done && (_a = configuration_1.return)) _a.call(configuration_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var adjList = getAdjList(configuration);
    try {
        // add descendants
        for (var configuration_2 = __values(configuration), configuration_2_1 = configuration_2.next(); !configuration_2_1.done; configuration_2_1 = configuration_2.next()) {
            var s = configuration_2_1.value;
            // if previously active, add existing child nodes
            if (s.type === 'compound' && (!adjList.get(s) || !adjList.get(s).length)) {
                if (prevAdjList.get(s)) {
                    prevAdjList.get(s).forEach(function (sn) { return configuration.add(sn); });
                }
                else {
                    s.initialStateNodes.forEach(function (sn) { return configuration.add(sn); });
                }
            }
            else {
                if (s.type === 'parallel') {
                    try {
                        for (var _e = (e_3 = void 0, __values(getChildren(s))), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var child = _f.value;
                            if (child.type === 'history') {
                                continue;
                            }
                            if (!configuration.has(child)) {
                                configuration.add(child);
                                if (prevAdjList.get(child)) {
                                    prevAdjList.get(child).forEach(function (sn) { return configuration.add(sn); });
                                }
                                else {
                                    child.initialStateNodes.forEach(function (sn) { return configuration.add(sn); });
                                }
                            }
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_c = _e.return)) _c.call(_e);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (configuration_2_1 && !configuration_2_1.done && (_b = configuration_2.return)) _b.call(configuration_2);
        }
        finally { if (e_2) throw e_2.error; }
    }
    try {
        // add all ancestors
        for (var configuration_3 = __values(configuration), configuration_3_1 = configuration_3.next(); !configuration_3_1.done; configuration_3_1 = configuration_3.next()) {
            var s = configuration_3_1.value;
            var m = s.parent;
            while (m && !configuration.has(m)) {
                configuration.add(m);
                m = m.parent;
            }
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (configuration_3_1 && !configuration_3_1.done && (_d = configuration_3.return)) _d.call(configuration_3);
        }
        finally { if (e_4) throw e_4.error; }
    }
    return configuration;
}
exports.getConfiguration = getConfiguration;
function getValueFromAdj(baseNode, adjList) {
    var childStateNodes = adjList.get(baseNode);
    if (!childStateNodes) {
        return {}; // todo: fix?
    }
    if (baseNode.type === 'compound') {
        var childStateNode = childStateNodes[0];
        if (childStateNode) {
            if (exports.isLeafNode(childStateNode)) {
                return childStateNode.key;
            }
        }
        else {
            return {};
        }
    }
    var stateValue = {};
    childStateNodes.forEach(function (csn) {
        stateValue[csn.key] = getValueFromAdj(csn, adjList);
    });
    return stateValue;
}
function getAdjList(configuration) {
    var e_5, _a;
    var adjList = new Map();
    try {
        for (var configuration_4 = __values(configuration), configuration_4_1 = configuration_4.next(); !configuration_4_1.done; configuration_4_1 = configuration_4.next()) {
            var s = configuration_4_1.value;
            if (!adjList.has(s)) {
                adjList.set(s, []);
            }
            if (s.parent) {
                if (!adjList.has(s.parent)) {
                    adjList.set(s.parent, []);
                }
                adjList.get(s.parent).push(s);
            }
        }
    }
    catch (e_5_1) { e_5 = { error: e_5_1 }; }
    finally {
        try {
            if (configuration_4_1 && !configuration_4_1.done && (_a = configuration_4.return)) _a.call(configuration_4);
        }
        finally { if (e_5) throw e_5.error; }
    }
    return adjList;
}
exports.getAdjList = getAdjList;
function getValue(rootNode, configuration) {
    var config = getConfiguration([rootNode], configuration);
    return getValueFromAdj(rootNode, getAdjList(config));
}
exports.getValue = getValue;
function has(iterable, item) {
    if (Array.isArray(iterable)) {
        return iterable.some(function (member) { return member === item; });
    }
    if (iterable instanceof Set) {
        return iterable.has(item);
    }
    return false; // TODO: fix
}
exports.has = has;
function nextEvents(configuration) {
    return utils_1.flatten(__spread(new Set(configuration.map(function (sn) { return sn.ownEvents; }))));
}
exports.nextEvents = nextEvents;
function isInFinalState(configuration, stateNode) {
    if (stateNode.type === 'compound') {
        return getChildren(stateNode).some(function (s) { return s.type === 'final' && has(configuration, s); });
    }
    if (stateNode.type === 'parallel') {
        return getChildren(stateNode).every(function (sn) {
            return isInFinalState(configuration, sn);
        });
    }
    return false;
}
exports.isInFinalState = isInFinalState;

},{"./utils":"e5f04d71d69884b4184956b7ea1c2036"}],"5adc8f58799118d0329ab2c28b9ab1b1":[function(require,module,exports) {
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveActions = exports.choose = exports.escalate = exports.forwardTo = exports.pure = exports.error = exports.doneInvoke = exports.done = exports.after = exports.isActionObject = exports.assign = exports.resolveStop = exports.stop = exports.start = exports.cancel = exports.resolveLog = exports.log = exports.respond = exports.sendUpdate = exports.sendParent = exports.resolveSend = exports.send = exports.resolveRaise = exports.raise = exports.toActivityDefinition = exports.toActionObjects = exports.toActionObject = exports.getActionFunction = exports.initEvent = exports.actionTypes = void 0;
var types_1 = require("./types");
var actionTypes = require("./actionTypes");
exports.actionTypes = actionTypes;
var utils_1 = require("./utils");
var environment_1 = require("./environment");
exports.initEvent = utils_1.toSCXMLEvent({ type: actionTypes.init });
function getActionFunction(actionType, actionFunctionMap) {
    return actionFunctionMap
        ? actionFunctionMap[actionType] || undefined
        : undefined;
}
exports.getActionFunction = getActionFunction;
function toActionObject(action, actionFunctionMap) {
    var actionObject;
    if (utils_1.isString(action) || typeof action === 'number') {
        var exec = getActionFunction(action, actionFunctionMap);
        if (utils_1.isFunction(exec)) {
            actionObject = {
                type: action,
                exec: exec
            };
        }
        else if (exec) {
            actionObject = exec;
        }
        else {
            actionObject = { type: action, exec: undefined };
        }
    }
    else if (utils_1.isFunction(action)) {
        actionObject = {
            // Convert action to string if unnamed
            type: action.name || action.toString(),
            exec: action
        };
    }
    else {
        var exec = getActionFunction(action.type, actionFunctionMap);
        if (utils_1.isFunction(exec)) {
            actionObject = __assign(__assign({}, action), { exec: exec });
        }
        else if (exec) {
            var actionType = exec.type || action.type;
            actionObject = __assign(__assign(__assign({}, exec), action), { type: actionType });
        }
        else {
            actionObject = action;
        }
    }
    Object.defineProperty(actionObject, 'toString', {
        value: function () { return actionObject.type; },
        enumerable: false,
        configurable: true
    });
    return actionObject;
}
exports.toActionObject = toActionObject;
var toActionObjects = function (action, actionFunctionMap) {
    if (!action) {
        return [];
    }
    var actions = utils_1.isArray(action) ? action : [action];
    return actions.map(function (subAction) {
        return toActionObject(subAction, actionFunctionMap);
    });
};
exports.toActionObjects = toActionObjects;
function toActivityDefinition(action) {
    var actionObject = toActionObject(action);
    return __assign(__assign({ id: utils_1.isString(action) ? action : actionObject.id }, actionObject), { type: actionObject.type });
}
exports.toActivityDefinition = toActivityDefinition;
/**
 * Raises an event. This places the event in the internal event queue, so that
 * the event is immediately consumed by the machine in the current step.
 *
 * @param eventType The event to raise.
 */
function raise(event) {
    if (!utils_1.isString(event)) {
        return send(event, { to: types_1.SpecialTargets.Internal });
    }
    return {
        type: actionTypes.raise,
        event: event
    };
}
exports.raise = raise;
function resolveRaise(action) {
    return {
        type: actionTypes.raise,
        _event: utils_1.toSCXMLEvent(action.event)
    };
}
exports.resolveRaise = resolveRaise;
/**
 * Sends an event. This returns an action that will be read by an interpreter to
 * send the event in the next step, after the current step is finished executing.
 *
 * @param event The event to send.
 * @param options Options to pass into the send event:
 *  - `id` - The unique send event identifier (used with `cancel()`).
 *  - `delay` - The number of milliseconds to delay the sending of the event.
 *  - `to` - The target of this event (by default, the machine the event was sent from).
 */
function send(event, options) {
    return {
        to: options ? options.to : undefined,
        type: actionTypes.send,
        event: utils_1.isFunction(event) ? event : utils_1.toEventObject(event),
        delay: options ? options.delay : undefined,
        id: options && options.id !== undefined
            ? options.id
            : utils_1.isFunction(event)
                ? event.name
                : utils_1.getEventType(event)
    };
}
exports.send = send;
function resolveSend(action, ctx, _event, delaysMap) {
    var meta = {
        _event: _event
    };
    // TODO: helper function for resolving Expr
    var resolvedEvent = utils_1.toSCXMLEvent(utils_1.isFunction(action.event)
        ? action.event(ctx, _event.data, meta)
        : action.event);
    var resolvedDelay;
    if (utils_1.isString(action.delay)) {
        var configDelay = delaysMap && delaysMap[action.delay];
        resolvedDelay = utils_1.isFunction(configDelay)
            ? configDelay(ctx, _event.data, meta)
            : configDelay;
    }
    else {
        resolvedDelay = utils_1.isFunction(action.delay)
            ? action.delay(ctx, _event.data, meta)
            : action.delay;
    }
    var resolvedTarget = utils_1.isFunction(action.to)
        ? action.to(ctx, _event.data, meta)
        : action.to;
    return __assign(__assign({}, action), { to: resolvedTarget, _event: resolvedEvent, event: resolvedEvent.data, delay: resolvedDelay });
}
exports.resolveSend = resolveSend;
/**
 * Sends an event to this machine's parent.
 *
 * @param event The event to send to the parent machine.
 * @param options Options to pass into the send event.
 */
function sendParent(event, options) {
    return send(event, __assign(__assign({}, options), { to: types_1.SpecialTargets.Parent }));
}
exports.sendParent = sendParent;
/**
 * Sends an update event to this machine's parent.
 */
function sendUpdate() {
    return sendParent(actionTypes.update);
}
exports.sendUpdate = sendUpdate;
/**
 * Sends an event back to the sender of the original event.
 *
 * @param event The event to send back to the sender
 * @param options Options to pass into the send event
 */
function respond(event, options) {
    return send(event, __assign(__assign({}, options), { to: function (_, __, _a) {
            var _event = _a._event;
            return _event.origin; // TODO: handle when _event.origin is undefined
        } }));
}
exports.respond = respond;
var defaultLogExpr = function (context, event) { return ({
    context: context,
    event: event
}); };
/**
 *
 * @param expr The expression function to evaluate which will be logged.
 *  Takes in 2 arguments:
 *  - `ctx` - the current state context
 *  - `event` - the event that caused this action to be executed.
 * @param label The label to give to the logged expression.
 */
function log(expr, label) {
    if (expr === void 0) { expr = defaultLogExpr; }
    return {
        type: actionTypes.log,
        label: label,
        expr: expr
    };
}
exports.log = log;
var resolveLog = function (action, ctx, _event) { return (__assign(__assign({}, action), { value: utils_1.isString(action.expr)
        ? action.expr
        : action.expr(ctx, _event.data, {
            _event: _event
        }) })); };
exports.resolveLog = resolveLog;
/**
 * Cancels an in-flight `send(...)` action. A canceled sent action will not
 * be executed, nor will its event be sent, unless it has already been sent
 * (e.g., if `cancel(...)` is called after the `send(...)` action's `delay`).
 *
 * @param sendId The `id` of the `send(...)` action to cancel.
 */
var cancel = function (sendId) {
    return {
        type: actionTypes.cancel,
        sendId: sendId
    };
};
exports.cancel = cancel;
/**
 * Starts an activity.
 *
 * @param activity The activity to start.
 */
function start(activity) {
    var activityDef = toActivityDefinition(activity);
    return {
        type: types_1.ActionTypes.Start,
        activity: activityDef,
        exec: undefined
    };
}
exports.start = start;
/**
 * Stops an activity.
 *
 * @param actorRef The activity to stop.
 */
function stop(actorRef) {
    var activity = utils_1.isFunction(actorRef)
        ? actorRef
        : toActivityDefinition(actorRef);
    return {
        type: types_1.ActionTypes.Stop,
        activity: activity,
        exec: undefined
    };
}
exports.stop = stop;
function resolveStop(action, context, _event) {
    var actorRefOrString = utils_1.isFunction(action.activity)
        ? action.activity(context, _event.data)
        : action.activity;
    var resolvedActorRef = typeof actorRefOrString === 'string'
        ? { id: actorRefOrString }
        : actorRefOrString;
    var actionObject = {
        type: types_1.ActionTypes.Stop,
        activity: resolvedActorRef
    };
    return actionObject;
}
exports.resolveStop = resolveStop;
/**
 * Updates the current context of the machine.
 *
 * @param assignment An object that represents the partial context to update.
 */
var assign = function (assignment) {
    return {
        type: actionTypes.assign,
        assignment: assignment
    };
};
exports.assign = assign;
function isActionObject(action) {
    return typeof action === 'object' && 'type' in action;
}
exports.isActionObject = isActionObject;
/**
 * Returns an event type that represents an implicit event that
 * is sent after the specified `delay`.
 *
 * @param delayRef The delay in milliseconds
 * @param id The state node ID where this event is handled
 */
function after(delayRef, id) {
    var idSuffix = id ? "#" + id : '';
    return types_1.ActionTypes.After + "(" + delayRef + ")" + idSuffix;
}
exports.after = after;
/**
 * Returns an event that represents that a final state node
 * has been reached in the parent state node.
 *
 * @param id The final state node's parent state node `id`
 * @param data The data to pass into the event
 */
function done(id, data) {
    var type = types_1.ActionTypes.DoneState + "." + id;
    var eventObject = {
        type: type,
        data: data
    };
    eventObject.toString = function () { return type; };
    return eventObject;
}
exports.done = done;
/**
 * Returns an event that represents that an invoked service has terminated.
 *
 * An invoked service is terminated when it has reached a top-level final state node,
 * but not when it is canceled.
 *
 * @param id The final state node ID
 * @param data The data to pass into the event
 */
function doneInvoke(id, data) {
    var type = types_1.ActionTypes.DoneInvoke + "." + id;
    var eventObject = {
        type: type,
        data: data
    };
    eventObject.toString = function () { return type; };
    return eventObject;
}
exports.doneInvoke = doneInvoke;
function error(id, data) {
    var type = types_1.ActionTypes.ErrorPlatform + "." + id;
    var eventObject = { type: type, data: data };
    eventObject.toString = function () { return type; };
    return eventObject;
}
exports.error = error;
function pure(getActions) {
    return {
        type: types_1.ActionTypes.Pure,
        get: getActions
    };
}
exports.pure = pure;
/**
 * Forwards (sends) an event to a specified service.
 *
 * @param target The target service to forward the event to.
 * @param options Options to pass into the send action creator.
 */
function forwardTo(target, options) {
    return send(function (_, event) { return event; }, __assign(__assign({}, options), { to: target }));
}
exports.forwardTo = forwardTo;
/**
 * Escalates an error by sending it as an event to this machine's parent.
 *
 * @param errorData The error data to send, or the expression function that
 * takes in the `context`, `event`, and `meta`, and returns the error data to send.
 * @param options Options to pass into the send action creator.
 */
function escalate(errorData, options) {
    return sendParent(function (context, event, meta) {
        return {
            type: actionTypes.error,
            data: utils_1.isFunction(errorData)
                ? errorData(context, event, meta)
                : errorData
        };
    }, __assign(__assign({}, options), { to: types_1.SpecialTargets.Parent }));
}
exports.escalate = escalate;
function choose(conds) {
    return {
        type: types_1.ActionTypes.Choose,
        conds: conds
    };
}
exports.choose = choose;
function resolveActions(machine, currentState, currentContext, _event, actions) {
    var _a = __read(utils_1.partition(actions, function (action) {
        return action.type === actionTypes.assign;
    }), 2), assignActions = _a[0], otherActions = _a[1];
    var updatedContext = assignActions.length
        ? utils_1.updateContext(currentContext, _event, assignActions, currentState)
        : currentContext;
    var resolvedActions = utils_1.flatten(otherActions.map(function (actionObject) {
        var _a;
        switch (actionObject.type) {
            case actionTypes.raise:
                return resolveRaise(actionObject);
            case actionTypes.send:
                var sendAction = resolveSend(actionObject, updatedContext, _event, machine.options.delays); // TODO: fix ActionTypes.Init
                if (!environment_1.IS_PRODUCTION) {
                    // warn after resolving as we can create better contextual message here
                    utils_1.warn(!utils_1.isString(actionObject.delay) ||
                        typeof sendAction.delay === 'number', 
                    // tslint:disable-next-line:max-line-length
                    "No delay reference for delay expression '" + actionObject.delay + "' was found on machine '" + machine.id + "'");
                }
                return sendAction;
            case actionTypes.log:
                return exports.resolveLog(actionObject, updatedContext, _event);
            case actionTypes.choose: {
                var chooseAction = actionObject;
                var matchedActions = (_a = chooseAction.conds.find(function (condition) {
                    var guard = utils_1.toGuard(condition.cond, machine.options.guards);
                    return (!guard ||
                        utils_1.evaluateGuard(machine, guard, updatedContext, _event, currentState));
                })) === null || _a === void 0 ? void 0 : _a.actions;
                if (!matchedActions) {
                    return [];
                }
                var resolved = resolveActions(machine, currentState, updatedContext, _event, exports.toActionObjects(utils_1.toArray(matchedActions), machine.options.actions));
                updatedContext = resolved[1];
                return resolved[0];
            }
            case actionTypes.pure: {
                var matchedActions = actionObject.get(updatedContext, _event.data);
                if (!matchedActions) {
                    return [];
                }
                var resolved = resolveActions(machine, currentState, updatedContext, _event, exports.toActionObjects(utils_1.toArray(matchedActions), machine.options.actions));
                updatedContext = resolved[1];
                return resolved[0];
            }
            case actionTypes.stop: {
                return resolveStop(actionObject, updatedContext, _event);
            }
            default:
                return toActionObject(actionObject, machine.options.actions);
        }
    }));
    return [resolvedActions, updatedContext];
}
exports.resolveActions = resolveActions;

},{"./types":"c548ffd845c55f4fd347026b8ab58cb7","./actionTypes":"b37dca994227f949b5b489aadf8f0f92","./utils":"e5f04d71d69884b4184956b7ea1c2036","./environment":"6dbe9637d67ccc4648d820c8714c7766"}],"b37dca994227f949b5b489aadf8f0f92":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pure = exports.choose = exports.update = exports.error = exports.errorPlatform = exports.errorExecution = exports.invoke = exports.init = exports.log = exports.doneState = exports.after = exports.assign = exports.nullEvent = exports.cancel = exports.send = exports.raise = exports.stop = exports.start = void 0;
var types_1 = require("./types");
// xstate-specific action types
exports.start = types_1.ActionTypes.Start;
exports.stop = types_1.ActionTypes.Stop;
exports.raise = types_1.ActionTypes.Raise;
exports.send = types_1.ActionTypes.Send;
exports.cancel = types_1.ActionTypes.Cancel;
exports.nullEvent = types_1.ActionTypes.NullEvent;
exports.assign = types_1.ActionTypes.Assign;
exports.after = types_1.ActionTypes.After;
exports.doneState = types_1.ActionTypes.DoneState;
exports.log = types_1.ActionTypes.Log;
exports.init = types_1.ActionTypes.Init;
exports.invoke = types_1.ActionTypes.Invoke;
exports.errorExecution = types_1.ActionTypes.ErrorExecution;
exports.errorPlatform = types_1.ActionTypes.ErrorPlatform;
exports.error = types_1.ActionTypes.ErrorCustom;
exports.update = types_1.ActionTypes.Update;
exports.choose = types_1.ActionTypes.Choose;
exports.pure = types_1.ActionTypes.Pure;

},{"./types":"c548ffd845c55f4fd347026b8ab58cb7"}],"ebbbf0386563f93a004a28c3b372cf9b":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSpawnedActor = exports.isActor = exports.createDeferredActor = exports.createInvocableActor = exports.createNullActor = void 0;
var utils_1 = require("./utils");
var serviceScope = require("./serviceScope");
function createNullActor(id) {
    return {
        id: id,
        send: function () { return void 0; },
        subscribe: function () { return ({
            unsubscribe: function () { return void 0; }
        }); },
        toJSON: function () { return ({
            id: id
        }); }
    };
}
exports.createNullActor = createNullActor;
/**
 * Creates a deferred actor that is able to be invoked given the provided
 * invocation information in its `.meta` value.
 *
 * @param invokeDefinition The meta information needed to invoke the actor.
 */
function createInvocableActor(invokeDefinition, machine, context, _event) {
    var _a;
    var invokeSrc = utils_1.toInvokeSource(invokeDefinition.src);
    var serviceCreator = (_a = machine === null || machine === void 0 ? void 0 : machine.options.services) === null || _a === void 0 ? void 0 : _a[invokeSrc.type];
    var resolvedData = invokeDefinition.data
        ? utils_1.mapContext(invokeDefinition.data, context, _event)
        : undefined;
    var tempActor = serviceCreator
        ? createDeferredActor(serviceCreator, invokeDefinition.id, resolvedData)
        : createNullActor(invokeDefinition.id);
    tempActor.meta = invokeDefinition;
    return tempActor;
}
exports.createInvocableActor = createInvocableActor;
function createDeferredActor(entity, id, data) {
    var tempActor = createNullActor(id);
    tempActor.deferred = true;
    if (utils_1.isMachine(entity)) {
        // "mute" the existing service scope so potential spawned actors within the `.initialState` stay deferred here
        tempActor.state = serviceScope.provide(undefined, function () { return (data ? entity.withContext(data) : entity).initialState; });
    }
    return tempActor;
}
exports.createDeferredActor = createDeferredActor;
function isActor(item) {
    try {
        return typeof item.send === 'function';
    }
    catch (e) {
        return false;
    }
}
exports.isActor = isActor;
function isSpawnedActor(item) {
    return isActor(item) && 'id' in item;
}
exports.isSpawnedActor = isSpawnedActor;

},{"./utils":"e5f04d71d69884b4184956b7ea1c2036","./serviceScope":"efb9c8de6a724a516ce031b98b9d953b"}],"efb9c8de6a724a516ce031b98b9d953b":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.consume = exports.provide = void 0;
/**
 * Maintains a stack of the current service in scope.
 * This is used to provide the correct service to spawn().
 */
var serviceStack = [];
var provide = function (service, fn) {
    serviceStack.push(service);
    var result = fn(service);
    serviceStack.pop();
    return result;
};
exports.provide = provide;
var consume = function (fn) { return fn(serviceStack[serviceStack.length - 1]); };
exports.consume = consume;

},{}],"00b072b1a9d46c3e41491664fc951421":[function(require,module,exports) {
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toInvokeDefinition = exports.toInvokeSource = void 0;
var actions_1 = require("./actions");
function toInvokeSource(src) {
    if (typeof src === 'string') {
        var simpleSrc = { type: src };
        simpleSrc.toString = function () { return src; }; // v4 compat - TODO: remove in v5
        return simpleSrc;
    }
    return src;
}
exports.toInvokeSource = toInvokeSource;
function toInvokeDefinition(invokeConfig) {
    return __assign(__assign({ type: actions_1.actionTypes.invoke }, invokeConfig), { toJSON: function () {
            var onDone = invokeConfig.onDone, onError = invokeConfig.onError, invokeDef = __rest(invokeConfig, ["onDone", "onError"]);
            return __assign(__assign({}, invokeDef), { type: actions_1.actionTypes.invoke, src: toInvokeSource(invokeConfig.src) });
        } });
}
exports.toInvokeDefinition = toInvokeDefinition;

},{"./actions":"5adc8f58799118d0329ab2c28b9ab1b1"}],"dcff83593d02954ff92f02895bb211d7":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMachine = exports.Machine = void 0;
var StateNode_1 = require("./StateNode");
function Machine(config, options, initialContext) {
    if (initialContext === void 0) { initialContext = config.context; }
    var resolvedInitialContext = typeof initialContext === 'function'
        ? initialContext()
        : initialContext;
    return new StateNode_1.StateNode(config, options, resolvedInitialContext);
}
exports.Machine = Machine;
function createMachine(config, options) {
    var resolvedInitialContext = typeof config.context === 'function'
        ? config.context()
        : config.context;
    return new StateNode_1.StateNode(config, options, resolvedInitialContext);
}
exports.createMachine = createMachine;

},{"./StateNode":"d0978d565ef958bc66454c5b956f8408"}],"ce97f2817ba09c038dddca749dbf426c":[function(require,module,exports) {
"use strict";

var global = arguments[3];

var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var __values = this && this.__values || function (o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

var __read = this && this.__read || function (o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
};

var __spread = this && this.__spread || function () {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));

  return ar;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.interpret = exports.spawn = exports.Interpreter = exports.InterpreterStatus = void 0;

var types_1 = require("./types");

var State_1 = require("./State");

var actionTypes = require("./actionTypes");

var actions_1 = require("./actions");

var environment_1 = require("./environment");

var utils_1 = require("./utils");

var scheduler_1 = require("./scheduler");

var Actor_1 = require("./Actor");

var stateUtils_1 = require("./stateUtils");

var registry_1 = require("./registry");

var devTools_1 = require("./devTools");

var serviceScope = require("./serviceScope");

var DEFAULT_SPAWN_OPTIONS = {
  sync: false,
  autoForward: false
};
var InterpreterStatus;

(function (InterpreterStatus) {
  InterpreterStatus[InterpreterStatus["NotStarted"] = 0] = "NotStarted";
  InterpreterStatus[InterpreterStatus["Running"] = 1] = "Running";
  InterpreterStatus[InterpreterStatus["Stopped"] = 2] = "Stopped";
})(InterpreterStatus = exports.InterpreterStatus || (exports.InterpreterStatus = {}));

var Interpreter =
/** @class */
function () {
  /**
   * Creates a new Interpreter instance (i.e., service) for the given machine with the provided options, if any.
   *
   * @param machine The machine to be interpreted
   * @param options Interpreter options
   */
  function Interpreter(machine, options) {
    var _this = this;

    if (options === void 0) {
      options = Interpreter.defaultOptions;
    }

    this.machine = machine;
    this.scheduler = new scheduler_1.Scheduler();
    this.delayedEventsMap = {};
    this.listeners = new Set();
    this.contextListeners = new Set();
    this.stopListeners = new Set();
    this.doneListeners = new Set();
    this.eventListeners = new Set();
    this.sendListeners = new Set();
    /**
     * Whether the service is started.
     */

    this.initialized = false;
    this.status = InterpreterStatus.NotStarted;
    this.children = new Map();
    this.forwardTo = new Set();
    /**
     * Alias for Interpreter.prototype.start
     */

    this.init = this.start;
    /**
     * Sends an event to the running interpreter to trigger a transition.
     *
     * An array of events (batched) can be sent as well, which will send all
     * batched events to the running interpreter. The listeners will be
     * notified only **once** when all events are processed.
     *
     * @param event The event(s) to send
     */

    this.send = function (event, payload) {
      if (utils_1.isArray(event)) {
        _this.batch(event);

        return _this.state;
      }

      var _event = utils_1.toSCXMLEvent(utils_1.toEventObject(event, payload));

      if (_this.status === InterpreterStatus.Stopped) {
        // do nothing
        if (!environment_1.IS_PRODUCTION) {
          utils_1.warn(false, "Event \"" + _event.name + "\" was sent to stopped service \"" + _this.machine.id + "\". This service has already reached its final state, and will not transition.\nEvent: " + JSON.stringify(_event.data));
        }

        return _this.state;
      }

      if (_this.status !== InterpreterStatus.Running && !_this.options.deferEvents) {
        throw new Error("Event \"" + _event.name + "\" was sent to uninitialized service \"" + _this.machine.id + "\". Make sure .start() is called for this service, or set { deferEvents: true } in the service options.\nEvent: " + JSON.stringify(_event.data));
      }

      _this.scheduler.schedule(function () {
        // Forward copy of event to child actors
        _this.forward(_event);

        var nextState = _this.nextState(_event);

        _this.update(nextState, _event);
      });

      return _this._state; // TODO: deprecate (should return void)
      // tslint:disable-next-line:semicolon
    };

    this.sendTo = function (event, to) {
      var isParent = _this.parent && (to === types_1.SpecialTargets.Parent || _this.parent.id === to);
      var target = isParent ? _this.parent : utils_1.isString(to) ? _this.children.get(to) || registry_1.registry.get(to) : utils_1.isActor(to) ? to : undefined;

      if (!target) {
        if (!isParent) {
          throw new Error("Unable to send event to child '" + to + "' from service '" + _this.id + "'.");
        } // tslint:disable-next-line:no-console


        if (!environment_1.IS_PRODUCTION) {
          utils_1.warn(false, "Service '" + _this.id + "' has no parent: unable to send event " + event.type);
        }

        return;
      }

      if ('machine' in target) {
        // Send SCXML events to machines
        target.send(__assign(__assign({}, event), {
          name: event.name === actionTypes.error ? "" + actions_1.error(_this.id) : event.name,
          origin: _this.sessionId
        }));
      } else {
        // Send normal events to other targets
        target.send(event.data);
      }
    };

    var resolvedOptions = __assign(__assign({}, Interpreter.defaultOptions), options);

    var clock = resolvedOptions.clock,
        logger = resolvedOptions.logger,
        parent = resolvedOptions.parent,
        id = resolvedOptions.id;
    var resolvedId = id !== undefined ? id : machine.id;
    this.id = resolvedId;
    this.logger = logger;
    this.clock = clock;
    this.parent = parent;
    this.options = resolvedOptions;
    this.scheduler = new scheduler_1.Scheduler({
      deferEvents: this.options.deferEvents
    });
    this.sessionId = registry_1.registry.bookId();
  }

  Object.defineProperty(Interpreter.prototype, "initialState", {
    get: function () {
      var _this = this;

      if (this._initialState) {
        return this._initialState;
      }

      return serviceScope.provide(this, function () {
        _this._initialState = _this.machine.initialState;
        return _this._initialState;
      });
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Interpreter.prototype, "state", {
    get: function () {
      if (!environment_1.IS_PRODUCTION) {
        utils_1.warn(this.status !== InterpreterStatus.NotStarted, "Attempted to read state from uninitialized service '" + this.id + "'. Make sure the service is started first.");
      }

      return this._state;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Executes the actions of the given state, with that state's `context` and `event`.
   *
   * @param state The state whose actions will be executed
   * @param actionsConfig The action implementations to use
   */

  Interpreter.prototype.execute = function (state, actionsConfig) {
    var e_1, _a;

    try {
      for (var _b = __values(state.actions), _c = _b.next(); !_c.done; _c = _b.next()) {
        var action = _c.value;
        this.exec(action, state, actionsConfig);
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
  };

  Interpreter.prototype.update = function (state, _event) {
    var e_2, _a, e_3, _b, e_4, _c, e_5, _d;

    var _this = this; // Attach session ID to state


    state._sessionid = this.sessionId; // Update state

    this._state = state; // Execute actions

    if (this.options.execute) {
      this.execute(this.state);
    } // Update children


    this.children.forEach(function (child) {
      _this.state.children[child.id] = child;
    }); // Dev tools

    if (this.devTools) {
      this.devTools.send(_event.data, state);
    } // Execute listeners


    if (state.event) {
      try {
        for (var _e = __values(this.eventListeners), _f = _e.next(); !_f.done; _f = _e.next()) {
          var listener = _f.value;
          listener(state.event);
        }
      } catch (e_2_1) {
        e_2 = {
          error: e_2_1
        };
      } finally {
        try {
          if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
        } finally {
          if (e_2) throw e_2.error;
        }
      }
    }

    try {
      for (var _g = __values(this.listeners), _h = _g.next(); !_h.done; _h = _g.next()) {
        var listener = _h.value;
        listener(state, state.event);
      }
    } catch (e_3_1) {
      e_3 = {
        error: e_3_1
      };
    } finally {
      try {
        if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
      } finally {
        if (e_3) throw e_3.error;
      }
    }

    try {
      for (var _j = __values(this.contextListeners), _k = _j.next(); !_k.done; _k = _j.next()) {
        var contextListener = _k.value;
        contextListener(this.state.context, this.state.history ? this.state.history.context : undefined);
      }
    } catch (e_4_1) {
      e_4 = {
        error: e_4_1
      };
    } finally {
      try {
        if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
      } finally {
        if (e_4) throw e_4.error;
      }
    }

    var isDone = stateUtils_1.isInFinalState(state.configuration || [], this.machine);

    if (this.state.configuration && isDone) {
      // get final child state node
      var finalChildStateNode = state.configuration.find(function (sn) {
        return sn.type === 'final' && sn.parent === _this.machine;
      });
      var doneData = finalChildStateNode && finalChildStateNode.doneData ? utils_1.mapContext(finalChildStateNode.doneData, state.context, _event) : undefined;

      try {
        for (var _l = __values(this.doneListeners), _m = _l.next(); !_m.done; _m = _l.next()) {
          var listener = _m.value;
          listener(actions_1.doneInvoke(this.id, doneData));
        }
      } catch (e_5_1) {
        e_5 = {
          error: e_5_1
        };
      } finally {
        try {
          if (_m && !_m.done && (_d = _l.return)) _d.call(_l);
        } finally {
          if (e_5) throw e_5.error;
        }
      }

      this.stop();
    }
  };
  /*
   * Adds a listener that is notified whenever a state transition happens. The listener is called with
   * the next state and the event object that caused the state transition.
   *
   * @param listener The state listener
   */


  Interpreter.prototype.onTransition = function (listener) {
    this.listeners.add(listener); // Send current state to listener

    if (this.status === InterpreterStatus.Running) {
      listener(this.state, this.state.event);
    }

    return this;
  };

  Interpreter.prototype.subscribe = function (nextListenerOrObserver, _, // TODO: error listener
  completeListener) {
    var _this = this;

    if (!nextListenerOrObserver) {
      return {
        unsubscribe: function () {
          return void 0;
        }
      };
    }

    var listener;
    var resolvedCompleteListener = completeListener;

    if (typeof nextListenerOrObserver === 'function') {
      listener = nextListenerOrObserver;
    } else {
      listener = nextListenerOrObserver.next.bind(nextListenerOrObserver);
      resolvedCompleteListener = nextListenerOrObserver.complete.bind(nextListenerOrObserver);
    }

    this.listeners.add(listener); // Send current state to listener

    if (this.status === InterpreterStatus.Running) {
      listener(this.state);
    }

    if (resolvedCompleteListener) {
      this.onDone(resolvedCompleteListener);
    }

    return {
      unsubscribe: function () {
        listener && _this.listeners.delete(listener);
        resolvedCompleteListener && _this.doneListeners.delete(resolvedCompleteListener);
      }
    };
  };
  /**
   * Adds an event listener that is notified whenever an event is sent to the running interpreter.
   * @param listener The event listener
   */


  Interpreter.prototype.onEvent = function (listener) {
    this.eventListeners.add(listener);
    return this;
  };
  /**
   * Adds an event listener that is notified whenever a `send` event occurs.
   * @param listener The event listener
   */


  Interpreter.prototype.onSend = function (listener) {
    this.sendListeners.add(listener);
    return this;
  };
  /**
   * Adds a context listener that is notified whenever the state context changes.
   * @param listener The context listener
   */


  Interpreter.prototype.onChange = function (listener) {
    this.contextListeners.add(listener);
    return this;
  };
  /**
   * Adds a listener that is notified when the machine is stopped.
   * @param listener The listener
   */


  Interpreter.prototype.onStop = function (listener) {
    this.stopListeners.add(listener);
    return this;
  };
  /**
   * Adds a state listener that is notified when the statechart has reached its final state.
   * @param listener The state listener
   */


  Interpreter.prototype.onDone = function (listener) {
    this.doneListeners.add(listener);
    return this;
  };
  /**
   * Removes a listener.
   * @param listener The listener to remove
   */


  Interpreter.prototype.off = function (listener) {
    this.listeners.delete(listener);
    this.eventListeners.delete(listener);
    this.sendListeners.delete(listener);
    this.stopListeners.delete(listener);
    this.doneListeners.delete(listener);
    this.contextListeners.delete(listener);
    return this;
  };
  /**
   * Starts the interpreter from the given state, or the initial state.
   * @param initialState The state to start the statechart from
   */


  Interpreter.prototype.start = function (initialState) {
    var _this = this;

    if (this.status === InterpreterStatus.Running) {
      // Do not restart the service if it is already started
      return this;
    }

    registry_1.registry.register(this.sessionId, this);
    this.initialized = true;
    this.status = InterpreterStatus.Running;
    var resolvedState = initialState === undefined ? this.initialState : serviceScope.provide(this, function () {
      return State_1.isState(initialState) ? _this.machine.resolveState(initialState) : _this.machine.resolveState(State_1.State.from(initialState, _this.machine.context));
    });

    if (this.options.devTools) {
      this.attachDev();
    }

    this.scheduler.initialize(function () {
      _this.update(resolvedState, actions_1.initEvent);
    });
    return this;
  };
  /**
   * Stops the interpreter and unsubscribe all listeners.
   *
   * This will also notify the `onStop` listeners.
   */


  Interpreter.prototype.stop = function () {
    var e_6, _a, e_7, _b, e_8, _c, e_9, _d, e_10, _e;

    var _this = this;

    try {
      for (var _f = __values(this.listeners), _g = _f.next(); !_g.done; _g = _f.next()) {
        var listener = _g.value;
        this.listeners.delete(listener);
      }
    } catch (e_6_1) {
      e_6 = {
        error: e_6_1
      };
    } finally {
      try {
        if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
      } finally {
        if (e_6) throw e_6.error;
      }
    }

    try {
      for (var _h = __values(this.stopListeners), _j = _h.next(); !_j.done; _j = _h.next()) {
        var listener = _j.value; // call listener, then remove

        listener();
        this.stopListeners.delete(listener);
      }
    } catch (e_7_1) {
      e_7 = {
        error: e_7_1
      };
    } finally {
      try {
        if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
      } finally {
        if (e_7) throw e_7.error;
      }
    }

    try {
      for (var _k = __values(this.contextListeners), _l = _k.next(); !_l.done; _l = _k.next()) {
        var listener = _l.value;
        this.contextListeners.delete(listener);
      }
    } catch (e_8_1) {
      e_8 = {
        error: e_8_1
      };
    } finally {
      try {
        if (_l && !_l.done && (_c = _k.return)) _c.call(_k);
      } finally {
        if (e_8) throw e_8.error;
      }
    }

    try {
      for (var _m = __values(this.doneListeners), _o = _m.next(); !_o.done; _o = _m.next()) {
        var listener = _o.value;
        this.doneListeners.delete(listener);
      }
    } catch (e_9_1) {
      e_9 = {
        error: e_9_1
      };
    } finally {
      try {
        if (_o && !_o.done && (_d = _m.return)) _d.call(_m);
      } finally {
        if (e_9) throw e_9.error;
      }
    }

    if (!this.initialized) {
      // Interpreter already stopped; do nothing
      return this;
    }

    this.state.configuration.forEach(function (stateNode) {
      var e_11, _a;

      try {
        for (var _b = __values(stateNode.definition.exit), _c = _b.next(); !_c.done; _c = _b.next()) {
          var action = _c.value;

          _this.exec(action, _this.state);
        }
      } catch (e_11_1) {
        e_11 = {
          error: e_11_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally {
          if (e_11) throw e_11.error;
        }
      }
    }); // Stop all children

    this.children.forEach(function (child) {
      if (utils_1.isFunction(child.stop)) {
        child.stop();
      }
    });

    try {
      // Cancel all delayed events
      for (var _p = __values(utils_1.keys(this.delayedEventsMap)), _q = _p.next(); !_q.done; _q = _p.next()) {
        var key = _q.value;
        this.clock.clearTimeout(this.delayedEventsMap[key]);
      }
    } catch (e_10_1) {
      e_10 = {
        error: e_10_1
      };
    } finally {
      try {
        if (_q && !_q.done && (_e = _p.return)) _e.call(_p);
      } finally {
        if (e_10) throw e_10.error;
      }
    }

    this.scheduler.clear();
    this.initialized = false;
    this.status = InterpreterStatus.Stopped;
    registry_1.registry.free(this.sessionId);
    return this;
  };

  Interpreter.prototype.batch = function (events) {
    var _this = this;

    if (this.status === InterpreterStatus.NotStarted && this.options.deferEvents) {
      // tslint:disable-next-line:no-console
      if (!environment_1.IS_PRODUCTION) {
        utils_1.warn(false, events.length + " event(s) were sent to uninitialized service \"" + this.machine.id + "\" and are deferred. Make sure .start() is called for this service.\nEvent: " + JSON.stringify(event));
      }
    } else if (this.status !== InterpreterStatus.Running) {
      throw new Error( // tslint:disable-next-line:max-line-length
      events.length + " event(s) were sent to uninitialized service \"" + this.machine.id + "\". Make sure .start() is called for this service, or set { deferEvents: true } in the service options.");
    }

    this.scheduler.schedule(function () {
      var e_12, _a;

      var nextState = _this.state;
      var batchChanged = false;
      var batchedActions = [];

      var _loop_1 = function (event_1) {
        var _event = utils_1.toSCXMLEvent(event_1);

        _this.forward(_event);

        nextState = serviceScope.provide(_this, function () {
          return _this.machine.transition(nextState, _event);
        });
        batchedActions.push.apply(batchedActions, __spread(nextState.actions.map(function (a) {
          return State_1.bindActionToState(a, nextState);
        })));
        batchChanged = batchChanged || !!nextState.changed;
      };

      try {
        for (var events_1 = __values(events), events_1_1 = events_1.next(); !events_1_1.done; events_1_1 = events_1.next()) {
          var event_1 = events_1_1.value;

          _loop_1(event_1);
        }
      } catch (e_12_1) {
        e_12 = {
          error: e_12_1
        };
      } finally {
        try {
          if (events_1_1 && !events_1_1.done && (_a = events_1.return)) _a.call(events_1);
        } finally {
          if (e_12) throw e_12.error;
        }
      }

      nextState.changed = batchChanged;
      nextState.actions = batchedActions;

      _this.update(nextState, utils_1.toSCXMLEvent(events[events.length - 1]));
    });
  };
  /**
   * Returns a send function bound to this interpreter instance.
   *
   * @param event The event to be sent by the sender.
   */


  Interpreter.prototype.sender = function (event) {
    return this.send.bind(this, event);
  };
  /**
   * Returns the next state given the interpreter's current state and the event.
   *
   * This is a pure method that does _not_ update the interpreter's state.
   *
   * @param event The event to determine the next state
   */


  Interpreter.prototype.nextState = function (event) {
    var _this = this;

    var _event = utils_1.toSCXMLEvent(event);

    if (_event.name.indexOf(actionTypes.errorPlatform) === 0 && !this.state.nextEvents.some(function (nextEvent) {
      return nextEvent.indexOf(actionTypes.errorPlatform) === 0;
    })) {
      throw _event.data.data;
    }

    var nextState = serviceScope.provide(this, function () {
      return _this.machine.transition(_this.state, _event);
    });
    return nextState;
  };

  Interpreter.prototype.forward = function (event) {
    var e_13, _a;

    try {
      for (var _b = __values(this.forwardTo), _c = _b.next(); !_c.done; _c = _b.next()) {
        var id = _c.value;
        var child = this.children.get(id);

        if (!child) {
          throw new Error("Unable to forward event '" + event + "' from interpreter '" + this.id + "' to nonexistant child '" + id + "'.");
        }

        child.send(event);
      }
    } catch (e_13_1) {
      e_13 = {
        error: e_13_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_13) throw e_13.error;
      }
    }
  };

  Interpreter.prototype.defer = function (sendAction) {
    var _this = this;

    this.delayedEventsMap[sendAction.id] = this.clock.setTimeout(function () {
      if (sendAction.to) {
        _this.sendTo(sendAction._event, sendAction.to);
      } else {
        _this.send(sendAction._event);
      }
    }, sendAction.delay);
  };

  Interpreter.prototype.cancel = function (sendId) {
    this.clock.clearTimeout(this.delayedEventsMap[sendId]);
    delete this.delayedEventsMap[sendId];
  };

  Interpreter.prototype.exec = function (action, state, actionFunctionMap) {
    if (actionFunctionMap === void 0) {
      actionFunctionMap = this.machine.options.actions;
    }

    var context = state.context,
        _event = state._event;
    var actionOrExec = action.exec || actions_1.getActionFunction(action.type, actionFunctionMap);
    var exec = utils_1.isFunction(actionOrExec) ? actionOrExec : actionOrExec ? actionOrExec.exec : action.exec;

    if (exec) {
      try {
        return exec(context, _event.data, {
          action: action,
          state: this.state,
          _event: _event
        });
      } catch (err) {
        if (this.parent) {
          this.parent.send({
            type: 'xstate.error',
            data: err
          });
        }

        throw err;
      }
    }

    switch (action.type) {
      case actionTypes.send:
        var sendAction = action;

        if (typeof sendAction.delay === 'number') {
          this.defer(sendAction);
          return;
        } else {
          if (sendAction.to) {
            this.sendTo(sendAction._event, sendAction.to);
          } else {
            this.send(sendAction._event);
          }
        }

        break;

      case actionTypes.cancel:
        this.cancel(action.sendId);
        break;

      case actionTypes.start:
        {
          var activity = action.activity; // If the activity will be stopped right after it's started
          // (such as in transient states)
          // don't bother starting the activity.

          if (!this.state.activities[activity.id || activity.type]) {
            break;
          } // Invoked services


          if (activity.type === types_1.ActionTypes.Invoke) {
            var invokeSource = utils_1.toInvokeSource(activity.src);
            var serviceCreator = this.machine.options.services ? this.machine.options.services[invokeSource.type] : undefined;
            var id = activity.id,
                data = activity.data;

            if (!environment_1.IS_PRODUCTION) {
              utils_1.warn(!('forward' in activity), // tslint:disable-next-line:max-line-length
              "`forward` property is deprecated (found in invocation of '" + activity.src + "' in in machine '" + this.machine.id + "'). " + "Please use `autoForward` instead.");
            }

            var autoForward = 'autoForward' in activity ? activity.autoForward : !!activity.forward;

            if (!serviceCreator) {
              // tslint:disable-next-line:no-console
              if (!environment_1.IS_PRODUCTION) {
                utils_1.warn(false, "No service found for invocation '" + activity.src + "' in machine '" + this.machine.id + "'.");
              }

              return;
            }

            var resolvedData = data ? utils_1.mapContext(data, context, _event) : undefined;
            var source = utils_1.isFunction(serviceCreator) ? serviceCreator(context, _event.data, {
              data: resolvedData,
              src: invokeSource
            }) : serviceCreator;

            if (utils_1.isPromiseLike(source)) {
              this.spawnPromise(Promise.resolve(source), id);
            } else if (utils_1.isFunction(source)) {
              this.spawnCallback(source, id);
            } else if (utils_1.isObservable(source)) {
              this.spawnObservable(source, id);
            } else if (utils_1.isMachine(source)) {
              // TODO: try/catch here
              this.spawnMachine(resolvedData ? source.withContext(resolvedData) : source, {
                id: id,
                autoForward: autoForward
              });
            } else {// service is string
            }
          } else {
            this.spawnActivity(activity);
          }

          break;
        }

      case actionTypes.stop:
        {
          this.stopChild(action.activity.id);
          break;
        }

      case actionTypes.log:
        var label = action.label,
            value = action.value;

        if (label) {
          this.logger(label, value);
        } else {
          this.logger(value);
        }

        break;

      default:
        if (!environment_1.IS_PRODUCTION) {
          utils_1.warn(false, "No implementation found for action type '" + action.type + "'");
        }

        break;
    }

    return undefined;
  };

  Interpreter.prototype.removeChild = function (childId) {
    this.children.delete(childId);
    this.forwardTo.delete(childId);
    delete this.state.children[childId];
  };

  Interpreter.prototype.stopChild = function (childId) {
    var child = this.children.get(childId);

    if (!child) {
      return;
    }

    this.removeChild(childId);

    if (utils_1.isFunction(child.stop)) {
      child.stop();
    }
  };

  Interpreter.prototype.spawn = function (entity, name, options) {
    if (utils_1.isPromiseLike(entity)) {
      return this.spawnPromise(Promise.resolve(entity), name);
    } else if (utils_1.isFunction(entity)) {
      return this.spawnCallback(entity, name);
    } else if (Actor_1.isSpawnedActor(entity)) {
      return this.spawnActor(entity);
    } else if (utils_1.isObservable(entity)) {
      return this.spawnObservable(entity, name);
    } else if (utils_1.isMachine(entity)) {
      return this.spawnMachine(entity, __assign(__assign({}, options), {
        id: name
      }));
    } else {
      throw new Error("Unable to spawn entity \"" + name + "\" of type \"" + typeof entity + "\".");
    }
  };

  Interpreter.prototype.spawnMachine = function (machine, options) {
    var _this = this;

    if (options === void 0) {
      options = {};
    }

    var childService = new Interpreter(machine, __assign(__assign({}, this.options), {
      parent: this,
      id: options.id || machine.id
    }));

    var resolvedOptions = __assign(__assign({}, DEFAULT_SPAWN_OPTIONS), options);

    if (resolvedOptions.sync) {
      childService.onTransition(function (state) {
        _this.send(actionTypes.update, {
          state: state,
          id: childService.id
        });
      });
    }

    var actor = childService;
    this.children.set(childService.id, actor);

    if (resolvedOptions.autoForward) {
      this.forwardTo.add(childService.id);
    }

    childService.onDone(function (doneEvent) {
      _this.removeChild(childService.id);

      _this.send(utils_1.toSCXMLEvent(doneEvent, {
        origin: childService.id
      }));
    }).start();
    return actor;
  };

  Interpreter.prototype.spawnPromise = function (promise, id) {
    var _this = this;

    var canceled = false;
    promise.then(function (response) {
      if (!canceled) {
        _this.removeChild(id);

        _this.send(utils_1.toSCXMLEvent(actions_1.doneInvoke(id, response), {
          origin: id
        }));
      }
    }, function (errorData) {
      if (!canceled) {
        _this.removeChild(id);

        var errorEvent = actions_1.error(id, errorData);

        try {
          // Send "error.platform.id" to this (parent).
          _this.send(utils_1.toSCXMLEvent(errorEvent, {
            origin: id
          }));
        } catch (error) {
          utils_1.reportUnhandledExceptionOnInvocation(errorData, error, id);

          if (_this.devTools) {
            _this.devTools.send(errorEvent, _this.state);
          }

          if (_this.machine.strict) {
            // it would be better to always stop the state machine if unhandled
            // exception/promise rejection happens but because we don't want to
            // break existing code so enforce it on strict mode only especially so
            // because documentation says that onError is optional
            _this.stop();
          }
        }
      }
    });
    var actor = {
      id: id,
      send: function () {
        return void 0;
      },
      subscribe: function (next, handleError, complete) {
        var observer = utils_1.toObserver(next, handleError, complete);
        var unsubscribed = false;
        promise.then(function (response) {
          if (unsubscribed) {
            return;
          }

          observer.next(response);

          if (unsubscribed) {
            return;
          }

          observer.complete();
        }, function (err) {
          if (unsubscribed) {
            return;
          }

          observer.error(err);
        });
        return {
          unsubscribe: function () {
            return unsubscribed = true;
          }
        };
      },
      stop: function () {
        canceled = true;
      },
      toJSON: function () {
        return {
          id: id
        };
      }
    };
    this.children.set(id, actor);
    return actor;
  };

  Interpreter.prototype.spawnCallback = function (callback, id) {
    var _this = this;

    var canceled = false;
    var receivers = new Set();
    var listeners = new Set();

    var receive = function (e) {
      listeners.forEach(function (listener) {
        return listener(e);
      });

      if (canceled) {
        return;
      }

      _this.send(utils_1.toSCXMLEvent(e, {
        origin: id
      }));
    };

    var callbackStop;

    try {
      callbackStop = callback(receive, function (newListener) {
        receivers.add(newListener);
      });
    } catch (err) {
      this.send(actions_1.error(id, err));
    }

    if (utils_1.isPromiseLike(callbackStop)) {
      // it turned out to be an async function, can't reliably check this before calling `callback`
      // because transpiled async functions are not recognizable
      return this.spawnPromise(callbackStop, id);
    }

    var actor = {
      id: id,
      send: function (event) {
        return receivers.forEach(function (receiver) {
          return receiver(event);
        });
      },
      subscribe: function (next) {
        listeners.add(next);
        return {
          unsubscribe: function () {
            listeners.delete(next);
          }
        };
      },
      stop: function () {
        canceled = true;

        if (utils_1.isFunction(callbackStop)) {
          callbackStop();
        }
      },
      toJSON: function () {
        return {
          id: id
        };
      }
    };
    this.children.set(id, actor);
    return actor;
  };

  Interpreter.prototype.spawnObservable = function (source, id) {
    var _this = this;

    var subscription = source.subscribe(function (value) {
      _this.send(utils_1.toSCXMLEvent(value, {
        origin: id
      }));
    }, function (err) {
      _this.removeChild(id);

      _this.send(utils_1.toSCXMLEvent(actions_1.error(id, err), {
        origin: id
      }));
    }, function () {
      _this.removeChild(id);

      _this.send(utils_1.toSCXMLEvent(actions_1.doneInvoke(id), {
        origin: id
      }));
    });
    var actor = {
      id: id,
      send: function () {
        return void 0;
      },
      subscribe: function (next, handleError, complete) {
        return source.subscribe(next, handleError, complete);
      },
      stop: function () {
        return subscription.unsubscribe();
      },
      toJSON: function () {
        return {
          id: id
        };
      }
    };
    this.children.set(id, actor);
    return actor;
  };

  Interpreter.prototype.spawnActor = function (actor) {
    this.children.set(actor.id, actor);
    return actor;
  };

  Interpreter.prototype.spawnActivity = function (activity) {
    var implementation = this.machine.options && this.machine.options.activities ? this.machine.options.activities[activity.type] : undefined;

    if (!implementation) {
      if (!environment_1.IS_PRODUCTION) {
        utils_1.warn(false, "No implementation found for activity '" + activity.type + "'");
      } // tslint:disable-next-line:no-console


      return;
    } // Start implementation


    var dispose = implementation(this.state.context, activity);
    this.spawnEffect(activity.id, dispose);
  };

  Interpreter.prototype.spawnEffect = function (id, dispose) {
    this.children.set(id, {
      id: id,
      send: function () {
        return void 0;
      },
      subscribe: function () {
        return {
          unsubscribe: function () {
            return void 0;
          }
        };
      },
      stop: dispose || undefined,
      toJSON: function () {
        return {
          id: id
        };
      }
    });
  };

  Interpreter.prototype.attachDev = function () {
    var global = devTools_1.getGlobal();

    if (this.options.devTools && global) {
      if (global.__REDUX_DEVTOOLS_EXTENSION__) {
        var devToolsOptions = typeof this.options.devTools === 'object' ? this.options.devTools : undefined;
        this.devTools = global.__REDUX_DEVTOOLS_EXTENSION__.connect(__assign(__assign({
          name: this.id,
          autoPause: true,
          stateSanitizer: function (state) {
            return {
              value: state.value,
              context: state.context,
              actions: state.actions
            };
          }
        }, devToolsOptions), {
          features: __assign({
            jump: false,
            skip: false
          }, devToolsOptions ? devToolsOptions.features : undefined)
        }), this.machine);
        this.devTools.init(this.state);
      } // add XState-specific dev tooling hook


      devTools_1.registerService(this);
    }
  };

  Interpreter.prototype.toJSON = function () {
    return {
      id: this.id
    };
  };

  Interpreter.prototype[utils_1.symbolObservable] = function () {
    return this;
  };
  /**
   * The default interpreter options:
   *
   * - `clock` uses the global `setTimeout` and `clearTimeout` functions
   * - `logger` uses the global `console.log()` method
   */


  Interpreter.defaultOptions = function (global) {
    return {
      execute: true,
      deferEvents: true,
      clock: {
        setTimeout: function (fn, ms) {
          return setTimeout(fn, ms);
        },
        clearTimeout: function (id) {
          return clearTimeout(id);
        }
      },
      logger: global.console.log.bind(console),
      devTools: false
    };
  }(typeof self !== 'undefined' ? self : global);

  Interpreter.interpret = interpret;
  return Interpreter;
}();

exports.Interpreter = Interpreter;

var resolveSpawnOptions = function (nameOrOptions) {
  if (utils_1.isString(nameOrOptions)) {
    return __assign(__assign({}, DEFAULT_SPAWN_OPTIONS), {
      name: nameOrOptions
    });
  }

  return __assign(__assign(__assign({}, DEFAULT_SPAWN_OPTIONS), {
    name: utils_1.uniqueId()
  }), nameOrOptions);
};

function spawn(entity, nameOrOptions) {
  var resolvedOptions = resolveSpawnOptions(nameOrOptions);
  return serviceScope.consume(function (service) {
    if (!environment_1.IS_PRODUCTION) {
      var isLazyEntity = utils_1.isMachine(entity) || utils_1.isFunction(entity);
      utils_1.warn(!!service || isLazyEntity, "Attempted to spawn an Actor (ID: \"" + (utils_1.isMachine(entity) ? entity.id : 'undefined') + "\") outside of a service. This will have no effect.");
    }

    if (service) {
      return service.spawn(entity, resolvedOptions.name, resolvedOptions);
    } else {
      return Actor_1.createDeferredActor(entity, resolvedOptions.name);
    }
  });
}

exports.spawn = spawn;
/**
 * Creates a new Interpreter instance for the given machine with the provided options, if any.
 *
 * @param machine The machine to interpret
 * @param options Interpreter options
 */

function interpret(machine, options) {
  var interpreter = new Interpreter(machine, options);
  return interpreter;
}

exports.interpret = interpret;
},{"./types":"c548ffd845c55f4fd347026b8ab58cb7","./State":"fa8df89fc69b67a2024e57052242dafb","./actionTypes":"b37dca994227f949b5b489aadf8f0f92","./actions":"5adc8f58799118d0329ab2c28b9ab1b1","./environment":"6dbe9637d67ccc4648d820c8714c7766","./utils":"e5f04d71d69884b4184956b7ea1c2036","./scheduler":"ab5553a76f16823b54fce8707b1f95cf","./Actor":"ebbbf0386563f93a004a28c3b372cf9b","./stateUtils":"ae25440d22bedacc42657db575bb3ca7","./registry":"d5bba3f1e5cbc7c6075c51f56839ee4b","./devTools":"8072e6b6b72059dae0757ff1c57c764a","./serviceScope":"efb9c8de6a724a516ce031b98b9d953b"}],"ab5553a76f16823b54fce8707b1f95cf":[function(require,module,exports) {
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Scheduler = void 0;
var defaultOptions = {
    deferEvents: false
};
var Scheduler = /** @class */ (function () {
    function Scheduler(options) {
        this.processingEvent = false;
        this.queue = [];
        this.initialized = false;
        this.options = __assign(__assign({}, defaultOptions), options);
    }
    Scheduler.prototype.initialize = function (callback) {
        this.initialized = true;
        if (callback) {
            if (!this.options.deferEvents) {
                this.schedule(callback);
                return;
            }
            this.process(callback);
        }
        this.flushEvents();
    };
    Scheduler.prototype.schedule = function (task) {
        if (!this.initialized || this.processingEvent) {
            this.queue.push(task);
            return;
        }
        if (this.queue.length !== 0) {
            throw new Error('Event queue should be empty when it is not processing events');
        }
        this.process(task);
        this.flushEvents();
    };
    Scheduler.prototype.clear = function () {
        this.queue = [];
    };
    Scheduler.prototype.flushEvents = function () {
        var nextCallback = this.queue.shift();
        while (nextCallback) {
            this.process(nextCallback);
            nextCallback = this.queue.shift();
        }
    };
    Scheduler.prototype.process = function (callback) {
        this.processingEvent = true;
        try {
            callback();
        }
        catch (e) {
            // there is no use to keep the future events
            // as the situation is not anymore the same
            this.clear();
            throw e;
        }
        finally {
            this.processingEvent = false;
        }
    };
    return Scheduler;
}());
exports.Scheduler = Scheduler;

},{}],"d5bba3f1e5cbc7c6075c51f56839ee4b":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.registry = void 0;
var children = new Map();
var sessionIdIndex = 0;
exports.registry = {
    bookId: function () {
        return "x:" + sessionIdIndex++;
    },
    register: function (id, actor) {
        children.set(id, actor);
        return id;
    },
    get: function (id) {
        return children.get(id);
    },
    free: function (id) {
        children.delete(id);
    }
};

},{}],"8072e6b6b72059dae0757ff1c57c764a":[function(require,module,exports) {
"use strict";

var global = arguments[3];
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerService = exports.getGlobal = void 0;

var environment_1 = require("./environment"); // From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis


function getGlobal() {
  if (typeof self !== 'undefined') {
    return self;
  }

  if (typeof window !== 'undefined') {
    return window;
  }

  if (typeof global !== 'undefined') {
    return global;
  }

  return undefined;
}

exports.getGlobal = getGlobal;

function getDevTools() {
  var global = getGlobal();

  if (global && '__xstate__' in global) {
    return global.__xstate__;
  }

  return undefined;
}

function registerService(service) {
  if (environment_1.IS_PRODUCTION || !getGlobal()) {
    return;
  }

  var devTools = getDevTools();

  if (devTools) {
    devTools.register(service);
  }
}

exports.registerService = registerService;
},{"./environment":"6dbe9637d67ccc4648d820c8714c7766"}],"89b4c56c2c29d900a21adc9842ee7a36":[function(require,module,exports) {
"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.matchState = void 0;
var State_1 = require("./State");
function matchState(state, patterns, defaultValue) {
    var e_1, _a;
    var resolvedState = State_1.State.from(state, state instanceof State_1.State ? state.context : undefined);
    try {
        for (var patterns_1 = __values(patterns), patterns_1_1 = patterns_1.next(); !patterns_1_1.done; patterns_1_1 = patterns_1.next()) {
            var _b = __read(patterns_1_1.value, 2), stateValue = _b[0], getValue = _b[1];
            if (resolvedState.matches(stateValue)) {
                return getValue(resolvedState);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (patterns_1_1 && !patterns_1_1.done && (_a = patterns_1.return)) _a.call(patterns_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return defaultValue(resolvedState);
}
exports.matchState = matchState;

},{"./State":"fa8df89fc69b67a2024e57052242dafb"}],"60a98e37deb1add2bb95abeb6c37f73c":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadFile = exports.loadFolder = exports.pickFolder = exports.saveConfig = exports.loadConfig = void 0;

var fs = _interopRequireWildcard(require("tauri/api/fs"));

var dialog = _interopRequireWildcard(require("tauri/api/dialog"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const configDefaults = {
  appVersion: "1",
  lastDirectory: null
};

const loadConfig = async () => {
  const content = localStorage.getItem("config");
  const data = JSON.parse(content || "{}");
  return { ...configDefaults,
    ...data
  };
};

exports.loadConfig = loadConfig;

const saveConfig = async config => {
  localStorage.setItem("config", JSON.stringify({ ...configDefaults,
    ...config
  }));
  return Promise.resolve();
};

exports.saveConfig = saveConfig;

const pickFolder = async () => {
  const selection = await dialog.open({
    directory: true,
    multiple: false
  });
  return Array.isArray(selection) ? selection[0] : selection;
};

exports.pickFolder = pickFolder;

const loadFolder = async path => {
  return fs.readDir(path);
};

exports.loadFolder = loadFolder;

const loadFile = async path => {
  return fs.readTextFile(path);
};

exports.loadFile = loadFile;
},{"tauri/api/fs":"9bc0c556a7e9826bd30f465e9ab31081","tauri/api/dialog":"a603f74e3c49e0eafbcec1ba817e2c39"}],"9bc0c556a7e9826bd30f465e9ab31081":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),require("./tauri-fa600dd3.js");var e=require("./fs-e5ea6965.js");Object.defineProperty(exports,"BaseDirectory",{enumerable:!0,get:function(){return e.BaseDirectory}}),Object.defineProperty(exports,"Dir",{enumerable:!0,get:function(){return e.BaseDirectory}}),exports.copyFile=e.copyFile,exports.createDir=e.createDir,exports.readBinaryFile=e.readBinaryFile,exports.readDir=e.readDir,exports.readTextFile=e.readTextFile,exports.removeDir=e.removeDir,exports.removeFile=e.removeFile,exports.renameFile=e.renameFile,exports.writeBinaryFile=e.writeBinaryFile,exports.writeFile=e.writeFile;

},{"./tauri-fa600dd3.js":"c000e6e5fb8726de15b8e3e239bb4f61","./fs-e5ea6965.js":"e80cc5bb24d31bbff1984b7284181680"}],"c000e6e5fb8726de15b8e3e239bb4f61":[function(require,module,exports) {
"use strict";function e(e,t,n,r){return new(n||(n=Promise))((function(o,i){function a(e){try{c(r.next(e))}catch(e){i(e)}}function u(e){try{c(r.throw(e))}catch(e){i(e)}}function c(e){var t;e.done?o(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(a,u)}c((r=r.apply(e,t||[])).next())}))}function t(e,t){var n,r,o,i,a={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return i={next:u(0),throw:u(1),return:u(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function u(i){return function(u){return function(i){if(n)throw new TypeError("Generator is already executing.");for(;a;)try{if(n=1,r&&(o=2&i[0]?r.return:i[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,i[1])).done)return o;switch(r=0,o&&(i=[2&i[0],o.value]),i[0]){case 0:case 1:o=i;break;case 4:return a.label++,{value:i[1],done:!1};case 5:a.label++,r=i[1],i=[0];continue;case 7:i=a.ops.pop(),a.trys.pop();continue;default:if(!(o=a.trys,(o=o.length>0&&o[o.length-1])||6!==i[0]&&2!==i[0])){a=0;continue}if(3===i[0]&&(!o||i[1]>o[0]&&i[1]<o[3])){a.label=i[1];break}if(6===i[0]&&a.label<o[1]){a.label=o[1],o=i;break}if(o&&a.label<o[2]){a.label=o[2],a.ops.push(i);break}o[2]&&a.ops.pop(),a.trys.pop();continue}i=t.call(e,a)}catch(e){i=[6,e],r=0}finally{n=o=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,u])}}}function n(){return Math.floor(65536*(1+Math.random())).toString(16).substring(1)}function r(e){window.__TAURI_INVOKE_HANDLER__(e)}function o(e,t){void 0===t&&(t=!1);var r=n()+n()+"-"+n()+"-"+n()+"-"+n()+"-"+n()+n()+n();return Object.defineProperty(window,r,{value:function(n){return t&&Reflect.deleteProperty(window,r),null==e?void 0:e(n)},writable:!1,configurable:!0}),r}function i(n){return e(this,void 0,void 0,(function(){return t(this,(function(e){switch(e.label){case 0:return[4,new Promise((function(e,t){var i=o((function(t){e(t),Reflect.deleteProperty(window,a)}),!0),a=o((function(e){t(e),Reflect.deleteProperty(window,i)}),!0);r(exports._assign({callback:i,error:a},n))}))];case 1:return[2,e.sent()]}}))}))}exports._assign=function(){return exports._assign=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var o in t=arguments[n])Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o]);return e},exports._assign.apply(this,arguments)};var a=Object.freeze({__proto__:null,invoke:r,transformCallback:o,promisified:i});exports.__awaiter=e,exports.__generator=t,exports.invoke=r,exports.promisified=i,exports.tauri=a,exports.transformCallback=o;

},{}],"e80cc5bb24d31bbff1984b7284181680":[function(require,module,exports) {
"use strict";var e,t=require("./tauri-fa600dd3.js");function r(e,r){return void 0===r&&(r={}),t.__awaiter(this,void 0,void 0,(function(){return t.__generator(this,(function(i){switch(i.label){case 0:return[4,t.promisified({cmd:"readTextFile",path:e,options:r})];case 1:return[2,i.sent()]}}))}))}function i(e,r){return void 0===r&&(r={}),t.__awaiter(this,void 0,void 0,(function(){return t.__generator(this,(function(i){switch(i.label){case 0:return[4,t.promisified({cmd:"readBinaryFile",path:e,options:r})];case 1:return[2,i.sent()]}}))}))}function n(e,r){return void 0===r&&(r={}),t.__awaiter(this,void 0,void 0,(function(){return t.__generator(this,(function(i){switch(i.label){case 0:return"object"==typeof r&&Object.freeze(r),"object"==typeof e&&Object.freeze(e),[4,t.promisified({cmd:"writeFile",path:e.path,contents:e.contents,options:r})];case 1:return[2,i.sent()]}}))}))}(e=exports.BaseDirectory||(exports.BaseDirectory={}))[e.Audio=1]="Audio",e[e.Cache=2]="Cache",e[e.Config=3]="Config",e[e.Data=4]="Data",e[e.LocalData=5]="LocalData",e[e.Desktop=6]="Desktop",e[e.Document=7]="Document",e[e.Download=8]="Download",e[e.Executable=9]="Executable",e[e.Font=10]="Font",e[e.Home=11]="Home",e[e.Picture=12]="Picture",e[e.Public=13]="Public",e[e.Runtime=14]="Runtime",e[e.Template=15]="Template",e[e.Video=16]="Video",e[e.Resource=17]="Resource",e[e.App=18]="App";function o(e){var t=function(e){if(e.length<65536)return String.fromCharCode.apply(null,Array.from(e));for(var t="",r=e.length,i=0;i<r;i++){var n=e.subarray(65536*i,65536*(i+1));t+=String.fromCharCode.apply(null,Array.from(n))}return t}(new Uint8Array(e));return btoa(t)}function a(e,r){return void 0===r&&(r={}),t.__awaiter(this,void 0,void 0,(function(){return t.__generator(this,(function(i){switch(i.label){case 0:return"object"==typeof r&&Object.freeze(r),"object"==typeof e&&Object.freeze(e),[4,t.promisified({cmd:"writeBinaryFile",path:e.path,contents:o(e.contents),options:r})];case 1:return[2,i.sent()]}}))}))}function s(e,r){return void 0===r&&(r={}),t.__awaiter(this,void 0,void 0,(function(){return t.__generator(this,(function(i){switch(i.label){case 0:return[4,t.promisified({cmd:"readDir",path:e,options:r})];case 1:return[2,i.sent()]}}))}))}function c(e,r){return void 0===r&&(r={}),t.__awaiter(this,void 0,void 0,(function(){return t.__generator(this,(function(i){switch(i.label){case 0:return[4,t.promisified({cmd:"createDir",path:e,options:r})];case 1:return[2,i.sent()]}}))}))}function u(e,r){return void 0===r&&(r={}),t.__awaiter(this,void 0,void 0,(function(){return t.__generator(this,(function(i){switch(i.label){case 0:return[4,t.promisified({cmd:"removeDir",path:e,options:r})];case 1:return[2,i.sent()]}}))}))}function d(e,r,i){return void 0===i&&(i={}),t.__awaiter(this,void 0,void 0,(function(){return t.__generator(this,(function(n){switch(n.label){case 0:return[4,t.promisified({cmd:"copyFile",source:e,destination:r,options:i})];case 1:return[2,n.sent()]}}))}))}function p(e,r){return void 0===r&&(r={}),t.__awaiter(this,void 0,void 0,(function(){return t.__generator(this,(function(i){switch(i.label){case 0:return[4,t.promisified({cmd:"removeFile",path:e,options:r})];case 1:return[2,i.sent()]}}))}))}function l(e,r,i){return void 0===i&&(i={}),t.__awaiter(this,void 0,void 0,(function(){return t.__generator(this,(function(n){switch(n.label){case 0:return[4,t.promisified({cmd:"renameFile",oldPath:e,newPath:r,options:i})];case 1:return[2,n.sent()]}}))}))}var f=Object.freeze({__proto__:null,get BaseDirectory(){return exports.BaseDirectory},get Dir(){return exports.BaseDirectory},readTextFile:r,readBinaryFile:i,writeFile:n,writeBinaryFile:a,readDir:s,createDir:c,removeDir:u,copyFile:d,removeFile:p,renameFile:l});exports.copyFile=d,exports.createDir=c,exports.fs=f,exports.readBinaryFile=i,exports.readDir=s,exports.readTextFile=r,exports.removeDir=u,exports.removeFile=p,exports.renameFile=l,exports.writeBinaryFile=a,exports.writeFile=n;

},{"./tauri-fa600dd3.js":"c000e6e5fb8726de15b8e3e239bb4f61"}],"a603f74e3c49e0eafbcec1ba817e2c39":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),require("./tauri-fa600dd3.js");var e=require("./dialog-047c79ca.js");exports.open=e.open,exports.save=e.save;

},{"./tauri-fa600dd3.js":"c000e6e5fb8726de15b8e3e239bb4f61","./dialog-047c79ca.js":"8ea891103fd65ed5acd8cc81fc2ffb89"}],"8ea891103fd65ed5acd8cc81fc2ffb89":[function(require,module,exports) {
"use strict";var e=require("./tauri-fa600dd3.js");function t(t){return void 0===t&&(t={}),e.__awaiter(this,void 0,void 0,(function(){return e.__generator(this,(function(r){switch(r.label){case 0:return"object"==typeof t&&Object.freeze(t),[4,e.promisified({cmd:"openDialog",options:t})];case 1:return[2,r.sent()]}}))}))}function r(t){return void 0===t&&(t={}),e.__awaiter(this,void 0,void 0,(function(){return e.__generator(this,(function(r){switch(r.label){case 0:return"object"==typeof t&&Object.freeze(t),[4,e.promisified({cmd:"saveDialog",options:t})];case 1:return[2,r.sent()]}}))}))}var o=Object.freeze({__proto__:null,open:t,save:r});exports.dialog=o,exports.open=t,exports.save=r;

},{"./tauri-fa600dd3.js":"c000e6e5fb8726de15b8e3e239bb4f61"}],"5addf0f372c922390387c0c6184c34bc":[function() {},{}]},{},["581c8a36735eb2aed605e6b4b45f0b9f","6b8dee7d259922f234688c1068cceef0"], null)

//# sourceMappingURL=app.db9d3d9d.js.map
